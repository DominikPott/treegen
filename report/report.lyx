#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{multirow}
\usepackage{graphicx}
\newcommand{\terminaltext}[1]{{\footnotesize \colorbox{black}{\color{green}\texttt{#1}}}}
\graphicspath{ {images/} }
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Modelling of non-hero vegetation in Houdini
\begin_inset Newline newline
\end_inset


\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Author
Marta Feriani
\begin_inset Newline newline
\end_inset

s4900092
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset


\begin_inset Graphics
	filename images/BUlogo.png

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset FloatList figure

\end_inset


\begin_inset CommandInset toc
LatexCommand lstlistoflistings

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Abstract

\lang english
Vegetation modelling plays a key role in shots composition.
 Achieving a belieavable and true result has proven to be a tedious and
 time consuming task for artists.
 To overcome this issue we present a Houdini toolset for trees and flowers
 modelling.
 Through specifying different parameters values the toolset will generate
 a variety of tree and flowers species.
 Trees structures are achieved using the space colonization algorithm by
\lang british

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:runions2007]{Runions et al (2007)}
\end_layout

\end_inset

.
 Model parameters are meaningful to visual characteristics and offer an
 appropriate control over the silhouette and branching structure.
 Experiments show that the toolset can produce a reasonable variety of trees
 and flower species.
\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Section

\lang english
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:fearing]{Fearing (2000)}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
related works, motivation to do it in houdini
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/MPM.png
	lyxscale 50
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang english
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\lang english
MPM
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:MPM"

\end_inset

MPM method as implemented by 
\lang british

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:stomakhin]{Stomakhin et al (2013)}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Trees
\end_layout

\begin_layout Section
Related Works
\end_layout

\begin_layout Standard
The modelling of natural shapes such as trees is difficult because of the
 richness of small details.
 The history of trees 3D modelling starts with a recursive algorithm proposed
 by Honda (1971) REFERENCE!!!.
 The recursive structure relies on a few geometrical attributes such as
 branching angles and length ratio between consecutive segments.
 Honda also studies the nature of trees branching addressing the monopodial
 branching pattern as a special case for the dichotomous branching for structure
s that are parallel to the gravity.
 Honda's recursive approach has been at the core of many later modelling
 algorithms.
\end_layout

\begin_layout Standard
Lindenmayer (anno) REFERENCE!!!! introduced a string rewriting system know
 as L-System to describe the cellular interaction.
 An L-System is a formal grammar that consists of an alphabet, production
 rules and an axiom.
 The alphabet is a collection of symbols that can be used to produce strings.
 Production rules expand each symbol or string into some larger string.
 The axiom is used as starting point for the production.
 The string produced by iterating over the axiom can be later interpreted
 as geometric commands.
 Prusinkiewicz applies Lindenmayer rewriting system to plants structures
 adding few extensions such as context sensitivity and random variations.
\end_layout

\begin_layout Standard
L-Systems produce good results but the self similarity and the production
 patterns remain clearly visible in the final model.
 To overcome the pattern visibility, literature (REFERENCE) has introduced
 stochastic L-System which involves the selection of a production rule from
 the set based on a probability value.
 Other improvements on L-Systems involve the definition of a container volume
 for the L-System to grow into.
 Given the volume and an initial segment, the system will set the depth
 for the recursion.
\end_layout

\begin_layout Standard
Oppenheimer (anno) REFERENCE also relies on Honda recursive approach by
 developing natural patterns using fractals.
 The fractal specification is based on parameters such as branching angles,
 branch-to-prent ratio and branch-per-stem number.
 The fractal method by Oppenheimer was found to be affected by severe self
 similarity pattern visibility which gave the final shape a machine-made
 look.
 To overcome this problem 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Weber and Penn (1995)}
\end_layout

\end_inset

 improved the recursive model by adding randomness and organized functions
 to affect the tree development.
\end_layout

\begin_layout Standard
The interpretation of a tree as a recursive structure is justified by the
 process of tree development but plays a smaller role for fully grown trees.
 Buds may have different fate such as grown to major limbs, be shed or remain
 small twigs.
 In the architecture of a mature tree, therefore, the regularity of the
 recursive branching is mainly lost, overridden by subsequent development.
 Furthermore, finding rules and fitting parameters for recursive structures
 is a non trivial task.
 A small variation on the initial conditions will propagate exponentially
 through the generations becoming more and more evident.
 Once we managed to define the rules for a tree species, they often result
 to have nothing in common with other tree species.
 Even trying to tweak the existing rules to produce small variation on the
 produced model will drastically affect the whole new structure.
 Given the recursive nature of both L-System and fractals, even the use
 of random variables cannot completely overcome self-similarity issue and
 the resulting architectures give the machine-made impression.
\end_layout

\begin_layout Standard
New models for 3D tree modelling find common ground in the Runion et al
 REFERENCE approach developed for leaves venation.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Rodkaev et al (2003)}
\end_layout

\end_inset

 inherit Runion approach and apply it to a new algorithm based on particles
 that produces realistic leaves venation on a 2D space or a branching structure
 in a 3D space.
 Rodkaev populates a shape or a volume with particles.
 Each particle will move towards a predefined goal position merging with
 neighbours particles when the distance is smaller than a certain threshold.
 The trail for the particles trajectories generates the tree graph.
\end_layout

\begin_layout Section
The method
\end_layout

\begin_layout Standard
Similar to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Rodkaev et al (2003)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:runions2007]{Runions et al (2007)}
\end_layout

\end_inset

 suggest a space colonization algorithm as an extension of the 3D leaves
 venation by Runion et al REFERENCE.
 Unlike Rodkaev, Runions branching structure is formed in a base-to-leaves
 order.
 Each iteration of the algorithm produces new elements that expand the tree
 structure formed in the previous steps.
 This approach results not only to be adaptive to obstacle and neighbour
 plants, but also provides controls over the growth process that results
 in a wide variety of tree structures.
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
The algorithm proceeds as follows.
 A 3D envelope for the tree crown is specified as input.
 Its volume is seeded with a set of attraction points.
 The attraction points influence the growth of the tree structure by signalling
 the availability of empty space within the tree crown envelope.
 A single point is specified as input and acts as the base of the tree.
 Having the attracting points and the first tree point, the tree structure
 is generated as an iterative process.
 Each iteration produces new tree points in the direction of the neighbour
 attraction points to extend the existing tree structure.
 The algorithm may stop after a user defined number of iterations.
 If let running, the algorithm stops either when there are no attraction
 points within the radius of influence or when there are no attraction points
 left.
\end_layout

\begin_layout Standard
Further manipulation involves subdivision and smoothing of the internodes
 (branch that connects two consecutive nodes of the tree), skinning and
 scattering of organs such as leaves, flowers or fruits.
\end_layout

\begin_layout Subsection
Growth Algorithm
\begin_inset CommandInset label
LatexCommand label
name "subsec:Growth-Algorithm"

\end_inset


\end_layout

\begin_layout Standard
Competition for space plays a fundamental role in the colonization algorithm
 and determines the branching pattern for the tree structure.
 Before delving into the details of the algorithm some definitions and axioms
 are needed.
\end_layout

\begin_layout Subsubsection
Definitions and axioms
\end_layout

\begin_layout Enumerate
Every point the algorithm uses is either a tree node or an attraction node.
 From now on we will refer to tree nodes with 
\begin_inset Formula $v$
\end_inset

 and attraction nodes with 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $N$
\end_inset

 is the set of all the attraction points.
\begin_inset Formula 
\begin{equation}
\forall s,s\in N
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $T$
\end_inset

 is the set for the tree nodes
\begin_inset Formula 
\begin{equation}
\forall v,s\in N
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
If we refer to 
\begin_inset Formula $p$
\end_inset

 as a generic point in the algorithm
\begin_inset Formula 
\begin{equation}
\nexists p(p\in N\land p\in T)
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $S(v)$
\end_inset

 is the set of attraction points 
\begin_inset Formula $s$
\end_inset

 that influence the growth of the tree point 
\begin_inset Formula $v$
\end_inset

 for the current iteration.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $d(a,b)$
\end_inset

 is the Euler distance between point 
\begin_inset Formula $a$
\end_inset

 and point 
\begin_inset Formula $b$
\end_inset

 
\begin_inset Formula 
\begin{equation}
d(a,b)=\sqrt{(a.x-b.x)^{2}+(a.y-b.y)^{2}+(a.z-b.z)^{2}}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $di$
\end_inset

 is the 
\shape italic
radius of influence
\shape default
 which represents the maximum distance between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 so that 
\begin_inset Formula $s\in S(v)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $dk$
\end_inset

 is the 
\shape italic
kill distance
\shape default
.
 If 
\begin_inset Formula $d(s,v)$
\end_inset

 is less than 
\begin_inset Formula $dk$
\end_inset

, 
\begin_inset Formula $s$
\end_inset

 gets removed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $D$
\end_inset

 is the distance between consecutive nodes of the tree
\end_layout

\begin_layout Subsubsection
Steps
\end_layout

\begin_layout Enumerate
Define a 3D shape for the tree crown.
 Initialize the parameters N, di, dk, D.
\end_layout

\begin_layout Enumerate
Populate the 3D envelope with attraction points using a certain random distribut
ion.
\end_layout

\begin_layout Enumerate
Define at least one tree node to act as the base of the tree structure.
\end_layout

\begin_layout Enumerate
Each attraction point 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $s\in N$
\end_inset

, may influence the tree node 
\begin_inset Formula $v$
\end_inset

 that is closest to it.
 The influence occurs if 
\begin_inset Formula $d(s,v)<di$
\end_inset

.
 For each 
\begin_inset Formula $s\in N$
\end_inset

, check if there is any 
\begin_inset Formula $v\in T$
\end_inset

 that meets the condition.
 More than one attraction point may influence the same 
\begin_inset Formula $v$
\end_inset

 tree point: all the attraction points that influence 
\begin_inset Formula $v$
\end_inset

 are gathered in the 
\begin_inset Formula $S(v)$
\end_inset

 set.
\end_layout

\begin_layout Enumerate
For each tree node 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $v\in T$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
, if S(v) is not empty, a new tree node 
\begin_inset Formula $v^{\prime}$
\end_inset

is created.
 The new tree node lies at a distance 
\begin_inset Formula $D$
\end_inset

 from 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $v$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
 in the direction of the average of the normalized vectors towards the attractio
n points 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $s\in S(v)$
\end_inset


\begin_inset Formula 
\begin{equation}
v^{\prime}\in T
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
d(v,v^{\prime})=D
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\vec{n}=\sum_{s\in S(v)}\frac{s-v}{\shortparallel s-v\shortparallel}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\hat{n}=\frac{\vec{n}}{\shortparallel n\shortparallel}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
v^{\prime}=v+D\hat{n}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate

\lang english
perform a check to test, if any, attraction points 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $s\in N$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 should be removed if the following condition is true for at least one 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $v\in T$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
:
\begin_inset Formula 
\begin{equation}
d(s,v)<dk
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate

\lang english
repeat from steps 4 to 6 until we meet the stop conditions mentioned in
 HYPERREF!!!.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The network for the implementation of the growth algorithm relies on the
 layering of simple rules that eventually lead to the creation of the complexity
 that characterizes trees in nature.
 Houdini supports multiple scripting languages such as HScript, Python and
 VEX.
 Being Python widely used as scripting language and being a reality shared
 between many DCC software, it might seem the most sensible choice.
 On the other hand, VEX scripting language is Houdini native language.
 VEX gives direct access to geometry data and provides a wide variety of
 built-in function optimized for best performances on the Houdini geometry
 internal representation.
 In terms of performances, VEX has proven to be faster than Python because
 it implements automatic multithreading while Python does not have the same
 feature.
\end_layout

\begin_layout Subsection
Wrangle Node
\end_layout

\begin_layout Standard
The wrangle node REFERENCEEEEE is the most present node type in the network
 therefore it seemed only natural to give a brief explanation of how it
 works.
\end_layout

\begin_layout Standard
METTICI UNA IMMAGINE The attribute wrangle is a low level node that allows
 for the tweaking of the geometry attributes using VEX code.
 Its capabilities correspond to the Attribute VOP SOP.
 The main difference between the two of them is that wrangle uses a a textual
 editor whilst the Attribute VOP SOP uses a visual network.
\end_layout

\begin_layout Standard
The node can edit the input geometry by changing or adding attributes.
 It can also remove or create new geometry for example by adding points,
 linking points together to create polygons and so on.
 The snippet runs on details or on every point/primitive/vertex of the first
 input geometry.
 Using the multiple sources to the node it is also possible to access data
 from different geometry at the same time.
 When having multiple sources, only the first input geometry will flow down
 to the next node of the network whilst the other input geometries will
 be lost.
\end_layout

\begin_layout Standard
When the snippet affects the attributes of the geometry, these attribute
 will not be available until the node is cooked.
 This often makes is difficult to populate geometry attributes such as array
 within the same wrangle node.
 Due to this, the implementation of particular parts of the growth algorithm
 might not seem the most straightforward or obvious way to approach the
 problem but have been deliberately tweaked to overcome this particular
 issue.
\end_layout

\begin_layout Subsection
Data structure
\begin_inset CommandInset label
LatexCommand label
name "subsec:Data-structure"

\end_inset


\end_layout

\begin_layout Standard
The growth algorithm, as presented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Growth-Algorithm"

\end_inset

, mostly relies on points position.
 Each point has certain attributes to make it possible to create the tree
 structure.
 The attribute @type divides the point set in two main categories respectively
 the tree nodes and the attraction points.
 Given the nature of the algorithm, the total number of attraction points
 will decrease each iteration whilst every new node that will be created
 will increase the count for the tree nodes.
 To give a better visualization for this partition, the colour attribute
 @Cd is initialized to {1, 0.5, 0} for the tree node and to {0, 0.5, 1} for
 the attraction points.
\end_layout

\begin_layout Standard
The aim of the algorithm is to create a believable branching structure to
 reproduce natural trees.
 Stems might grow in only one direction or fork producing new stems.
 Older stems also grow thicker to balance the weight of the younger stems.
 This branching pattern can be represented by an acyclic graph data structure.
\end_layout

\begin_layout Standard
A graph is a finite collection of vertices and edges.
 Graph are used to model pairwise relations between object.
 The vertices, or nodes, represent the objects while the edges are the relations.
 The different nature of the relations leads to different kinds of graphs.
 In the case of a directed graph, each edge has an orientation, from one
 vertex to another vertex.
 A path is a sequence of edges.
 A node A is reachable by another node B if there exists a path that leads
 from A to B.
 If for each node in the graph there is no path that connects the node to
 itself, the graph is said to be acyclic.
 Being a graph a hierarchical structure, it is appropriate to address relationsh
ip between nodes as parent/child relationship.
 Each node is therefore aware either of its parent, its children or both.
 In computer science, to reproduce the relationships between nodes, each
 node contains a pointer to the connected ones.
 The network developed for this project provides each tree node with two
 attributes an integer and an array to store references to the parent and
 the children respectively.
 Unfortunately Houdini does not have pointers like structures.
 The points of a geometry are stored in an array like structure.
 The @ptnum attribute refers to the index of the point in that array.
 When referring to a point using the @ptnum attribute, one can gain direct
 access to that points other attributes, either built in or custom.
 Unfortunately, being the @ptnum ultimately just an index in an array, its
 value is not consistent through the network.
 Operation such as adding or removing points or merging together two geometry
 may shift or offset the @ptnum value.
 Given its unstable nature, the @ptnum did not seem to be a suitable choice
 to build parent/child relation upon.
 As a workaround, each treepoint also stores a unique identifier @id.
 Smaller @id values belong to older tree points while greater values belong
 to younger ones.
 When populating the @parent and @kids attributes, the reference to the
 other points will not be represented by the @ptnum but by the @id instead.
 Having to rely on a custom attribute such as the @id automatically translate
 into losing the direct access granted by the @ptnum.
 This greatly affects the performances of the whole algorithm because in
 order to find a node with a specific @id, one has to cycle over each point
 of the geometry and check for a match.
 In order not to loose this convenient feature, every time the algorithm
 has to work on the tree nodes, the sort node is used to remap the @ptnum
 based on the @id value.
 This solution allows for a reliable hierarchy structure while maintaining
 speed of access.
\end_layout

\begin_layout Standard
Another important information about the tree nodes is the grow direction
 and the length of the internode.
 Storing this values make it possible for a later more detailed manipulation
 of branching angles.
 Each point therefore stores a @growdir attribute that holds the normalized
 growth vector that links the parent to the node point position.
\end_layout

\begin_layout Standard
As a final step, each node also has two flags respectively for death and
 fertility.
 While the fertility flag signals if the node can produce a child in the
 current iteration and can be therefore non fertile and fertile in two consecuti
ve iteration, when the death flag is set it determines an irreversible condition
 for the node.
 A node dies whenever it reaches the maximum amount of children or for degenerat
ed cases such as the position of the child node being coincident with its
 own position.
\end_layout

\begin_layout Standard
As the information needed on a per node basis are quite important in terms
 of quantities, whenever an attribute is not needed any longer, it is removed
 from the geometry.
\end_layout

\begin_layout Subsection
Parameter initialization
\end_layout

\begin_layout Standard
define the 3D envelop, user input, choice on how many iteration, D, Dk,
 Di scaling factor (manipulated through the generations).
 Root point input as just points or a user selected trunk.
 Explanation of the algorithm for just nodes, new chapter for user defined
 trunk and branches.
\end_layout

\begin_layout Standard
In order for the growth algorithm to start, some parameters have to be set
 such as the tree crown envelope, the attraction points position and the
 roots points.
\end_layout

\begin_layout Subsubsection
Tree crown
\end_layout

\begin_layout Standard
simple, collision, wrap.
\end_layout

\begin_layout Subsubsection
Roots
\end_layout

\begin_layout Standard
The network provides three different ways to specify the roots for the growth
 algorithm.
 An user can either create single root points by specifying the coordinates,
 input a premade set of points or a trunk and branches curves structure.
\end_layout

\begin_layout Standard
For the first two option the initialization of the nodes attributes follows
 the same process.
 All the root points @parent is set to -1 to signal that they do not have
 any parent.
 As said before, the colour @Cd is initialized to yellow {1, 0.5, 0} and
 the @kids is declared as an empty array, the @type to 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

.
 Space will be allocated for for the @growdir @n_dead and @attr_dead.
 The initial values for these parameters are respectively {0, 0, 0}, 0 meaning
 that the node is alive and -1 to signal a default value.
\end_layout

\begin_layout Standard
The initialization of some attributes such as @parent, @kids and @type differs
 in the case of a custom trunk structure is fed in the system.
 This kind of structure already contains primitive information that link
 together points in a precise hierarchy.
 The most likely scenario is that each branch is represented as a curve
 primitive.
 The fork points of the structure will then belong to two different primitive
 at once, for example to both the trunk and a branch.
 The first attribute to be initialized is the @kids array using the 
\begin_inset Quotes eld
\end_inset

trunk_kids
\begin_inset Quotes erd
\end_inset

 snippet.
 This wrangle node is encapsulated in a for loop nodes block that will iterate
 on each primitive of the input geometry.
 The wrangle will therefore process the points of one primitive at the time.
 In the wrangle interface, the snippet is set to run over details so that
 the iteration process over the points is explicitly declared in in the
 code.
 The snippet starts by retrieving an ordered array of the current primitive
 points.
 A for loop then iterates over this array reading the point value and assigning
 the next point in the array to itself as @kids element.
 By using this approach, the snippet successfully handles specific cases
 in which the children to the point belong to different primitives.
 After having initialized the @kids attribute, the @parent comes straightforward
: the 
\begin_inset Quotes eld
\end_inset

trunk_parent
\begin_inset Quotes erd
\end_inset

 wrangle iterates over each point of the input geometry regardless the primitive
 they belong to.
 Each point will read its own @kids list and proceeds to set itself as @parent
 attribute to these points.
 One can refer to this process as parent injection.
 It is important to highlight that at this stage the @id attribute described
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Data-structure"

\end_inset

 has still not been initialized.
 The parent-children relation is built on the @ptnum.
 It is also important to understand that in this particular part of the
 network all the geometry being processed belongs to the tree structure.
 The @id can be therefore initialized as a plain copy of the @ptnum.
 Being @ptnum and @id coincident at this stage, the initialization process
 described results to be correct.
 As a next step, the @type has to be set.
 The implementation process makes sure that the user is given a certain
 extent of controls over the choice of root points for the growth algorithm.
 The network highlights as candidate roots all the points contained within
 the volume of the tree crown shape.
 The user can then decide which of them to keep.
 For the selected points, the @type is set to 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

 while the remaining ones are set to 
\begin_inset Quotes eld
\end_inset

trunk
\begin_inset Quotes erd
\end_inset

.
 During the growth algorithm, only the nodes will interact while the others
 will be lifeless.
 A final attribute @generation is initialized for all root points regardless
 whether they are single points or points being selected from a custom structure.
 This attribute plays a key role in a later part of the network to set and
 scale the cross section of the branches according to their age.
\end_layout

\begin_layout Subsection
Population of the envelope
\end_layout

\begin_layout Standard
3D shape turned to a volume, level of customization to wrap around object,
 interact with object.
\end_layout

\begin_layout Subsection
Growth
\end_layout

\begin_layout Standard
the whole subnetwork with the big loop
\end_layout

\begin_layout Subsubsection
Finding neighbours
\end_layout

\begin_layout Standard
separation between points, first on nodes to find possible influencing attractor
s, separate again between influencing and non influencing.
 input influencing and cycle over them to find closest tree node.
 append themselves on the nbrs attribute for the closest found tree node.
\end_layout

\begin_layout Subsubsection
Set fertility for the tree nodes
\end_layout

\begin_layout Part
Flowers
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Subsection
Network
\end_layout

\begin_layout Subsection
User Interface
\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Part*

\lang english
\begin_inset Newpage cleardoublepage
\end_inset

References
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{part}{References}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:houdini2017"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\lang english
Power Up Your Houdini Skills with SideFX, 2017.
 Making the Last Bastion.
 
\shape italic
3D World Magazine
\shape default
, 20 June 2017, Available from: https://issuu.com/futurepublishing/docs/houdini_i
ssuu [Accessed 24 July 2017].
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:schwank2016"

\end_inset


\end_layout

\begin_layout Standard
Schwank, A., James, C.
 J., Milciotta, T., 2016.
 The Trees of The Jungle Book.
 
\shape italic
SIGGRAPH ’16 Talks
\shape default
, 24-28 July 2016.
 Anaheim, CA: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:keim2016"

\end_inset


\end_layout

\begin_layout Standard
Keim, H., Simmons, M., Teece, D., Reisweber, J., Drakeley, S., 2016.
 Art-Directable Procedural Vegetation in Disney’s Zootopia.
 
\shape italic
SIGGRAPH ’16
\shape default
, 24-28 July 2016.
 Anaheim, CA: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:basalla2005"

\end_inset


\end_layout

\begin_layout Standard
Basalla, D., 2005.
 
\shape italic
Forest Generation with Maya and Renderman
\shape default
.
 Thesis (MSc).
 Bournemouth University.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:smurfs2017"

\end_inset


\end_layout

\begin_layout Standard
SideFX, 2017.
 
\shape italic
Smurfs: The Lost Village
\shape default
.
 sidefx.com, SideFx.
 Available from: https://www.sidefx.com/community/sony-imageworks-smurfs-the-lost-
village/ [Accessed 24 July 2017].
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:shek2010"

\end_inset


\end_layout

\begin_layout Standard
Shek, A., Lacewell, D., Selle, A., Teece, D., Thompson, T., 2010.
 Art-directing Disney's Tangled procedural trees.
 
\shape italic
SIGGRAPH 2010 Talks
\shape default
, 26 - 30 July Los Angeles.
 New York: ACM, 53.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:melson2016"

\end_inset


\end_layout

\begin_layout Standard
Melson, T., 2016.
 Can’t See The Jungle For The Trees.
 
\shape italic
SIGGRAPH ’16 Talks
\shape default
, 24 - 28 July Anaheim, CA.
 New York: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:soares2016"

\end_inset


\end_layout

\begin_layout Standard
Soares, O., Moser, M., Aalbers, F., 2016.
 Vegetation Choreography in The Good Dinosaur.
 
\shape italic
SIGGRAPH ’16 Talks
\shape default
, 24 - 28 July Anaheim, CA.
 New York: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:cieri2016"

\end_inset


\end_layout

\begin_layout Standard
Cieri, S., Muraca, A., Schwank, A., Preti, F., Micilotta, T., 2016.
 The Jungle Book: Art-Directing Procedural Scatters in Rich Environments.
 
\shape italic
DigiPro ’16
\shape default
, 23 - 23 July Anaheim, CA.
 New York: ACM, 57-59.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:runions2007"

\end_inset


\end_layout

\begin_layout Standard
Runions, A., Lane, B., Prusinkiewicz, P., 2007.
 Modeling Trees with a Space Colonization Algorithm.
 In: Ebert, D., Mérillou, S., 
\shape italic
NPH'07 Proceedings of the Third Eurographics conference on Natural Phenomena
\shape default
, 4 September 2007, Prague.
 Aire-la-Ville: Eurographics Association, 63-70.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:camilleri2016"

\end_inset


\end_layout

\begin_layout Standard
Camilleri, E., 2016.
 
\shape italic
Path Planning for Natural Phenomena
\shape default
.
 Thesis (MSc).
 Bournemouth University.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:wang2008"

\end_inset


\end_layout

\begin_layout Standard
Wang, C., Yang, K., Han, D., 2008.
 New Modeling Method for Trees.
 
\shape italic
2008 International Conference on Advanced Computer Theory and Engineering
\shape default
, 20-22 December 2008 Phuket.
 Los Vaqueros Circle: Institute of Electrical and Electronics Engineers
 ( IEEE ), 633-637.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:rodkaew2003"

\end_inset


\end_layout

\begin_layout Standard
Rodkaew, Y., Chongstitvatana, P., Siripani, S., Lursinsap, S., 2003.
 Particle Systems for Plant Modeling.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:weber1995"

\end_inset


\end_layout

\begin_layout Standard
Weber, J., Penn, J., 1995.
 Creation and Rendering of Realistic Trees.
 
\shape italic
22nd International ACM Conference on Computer Graphics and Interactive Technique
s
\shape default
, 6 - 11 August 1995 Los Angeles.
 New York: ACM, 119 - 128.
\end_layout

\end_body
\end_document
