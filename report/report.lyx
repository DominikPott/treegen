#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{multirow}
\usepackage{graphicx}
\newcommand{\terminaltext}[1]{{\footnotesize \colorbox{black}{\color{green}\texttt{#1}}}}
\graphicspath{ {images/} }
\usepackage{harvard}
\usepackage{url}
\usepackage{hyperref}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Modelling of non-hero vegetation in Houdini
\begin_inset Newline newline
\end_inset


\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Author
Marta Feriani
\begin_inset Newline newline
\end_inset

s4900092
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset


\begin_inset Graphics
	filename images/BUlogo.png

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset FloatList figure

\end_inset


\begin_inset CommandInset toc
LatexCommand lstlistoflistings

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Abstract

\lang english
Vegetation modelling plays a key role in shots composition.
 Achieving a belieavable and true result has proven to be a tedious and
 time consuming task for artists.
 To overcome this issue we present a Houdini toolset for trees and flowers
 modelling.
 Through specifying different parameters values the toolset will generate
 a variety of tree and flowers species.
 Trees structures are achieved using the space colonization algorithm by
\lang british

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:runions2007]{Runions et al (2007)}
\end_layout

\end_inset

.
 Model parameters are meaningful to visual characteristics and offer an
 appropriate control over the silhouette and branching structure.
 Experiments show that the toolset can produce a reasonable variety of trees
 and flower species.
\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Section

\lang english
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:fearing]{Fearing (2000)}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
related works, motivation to do it in houdini
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/MPM.png
	lyxscale 50
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang english
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\lang english
MPM
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:MPM"

\end_inset

MPM method as implemented by 
\lang british

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:stomakhin]{Stomakhin et al (2013)}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Trees
\end_layout

\begin_layout Section
Related Works
\end_layout

\begin_layout Standard
The modelling of natural shapes such as trees is difficult because of the
 richness of small details.
 The history of trees 3D modelling starts with a recursive algorithm proposed
 by Honda (1971) REFERENCE!!!.
 The recursive structure relies on a few geometrical attributes such as
 branching angles and length ratio between consecutive segments.
 Honda also studies the nature of trees branching addressing the monopodial
 branching pattern as a special case for the dichotomous branching for structure
s that are parallel to the gravity.
 Honda's recursive approach has been at the core of many later modelling
 algorithms.
\end_layout

\begin_layout Standard
Lindenmayer (anno) REFERENCE!!!! introduced a string rewriting system know
 as L-System to describe the cellular interaction.
 An L-System is a formal grammar that consists of an alphabet, production
 rules and an axiom.
 The alphabet is a collection of symbols that can be used to produce strings.
 Production rules expand each symbol or string into some larger string.
 The axiom is used as starting point for the production.
 The string produced by iterating over the axiom can be later interpreted
 as geometric commands.
 Prusinkiewicz applies Lindenmayer rewriting system to plants structures
 adding few extensions such as context sensitivity and random variations.
\end_layout

\begin_layout Standard
L-Systems produce good results but the self similarity and the production
 patterns remain clearly visible in the final model.
 To overcome the pattern visibility, literature (REFERENCE) has introduced
 stochastic L-System which involves the selection of a production rule from
 the set based on a probability value.
 Other improvements on L-Systems involve the definition of a container volume
 for the L-System to grow into.
 Given the volume and an initial segment, the system will set the depth
 for the recursion.
\end_layout

\begin_layout Standard
Oppenheimer (anno) REFERENCE also relies on Honda recursive approach by
 developing natural patterns using fractals.
 The fractal specification is based on parameters such as branching angles,
 branch-to-prent ratio and branch-per-stem number.
 The fractal method by Oppenheimer was found to be affected by severe self
 similarity pattern visibility which gave the final shape a machine-made
 look.
 To overcome this problem 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Weber and Penn (1995)}
\end_layout

\end_inset

 improved the recursive model by adding randomness and organized functions
 to affect the tree development.
\end_layout

\begin_layout Standard
The interpretation of a tree as a recursive structure is justified by the
 process of tree development but plays a smaller role for fully grown trees.
 Buds may have different fate such as grown to major limbs, be shed or remain
 small twigs.
 In the architecture of a mature tree, therefore, the regularity of the
 recursive branching is mainly lost, overridden by subsequent development.
 Furthermore, finding rules and fitting parameters for recursive structures
 is a non trivial task.
 A small variation on the initial conditions will propagate exponentially
 through the generations becoming more and more evident.
 Once we managed to define the rules for a tree species, they often result
 to have nothing in common with other tree species.
 Even trying to tweak the existing rules to produce small variation on the
 produced model will drastically affect the whole new structure.
 Given the recursive nature of both L-System and fractals, even the use
 of random variables cannot completely overcome self-similarity issue and
 the resulting architectures give the machine-made impression.
\end_layout

\begin_layout Standard
New models for 3D tree modelling find common ground in the Runion et al
 REFERENCE approach developed for leaves venation.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Rodkaev et al (2003)}
\end_layout

\end_inset

 inherit Runion approach and apply it to a new algorithm based on particles
 that produces realistic leaves venation on a 2D space or a branching structure
 in a 3D space.
 Rodkaev populates a shape or a volume with particles.
 Each particle will move towards a predefined goal position merging with
 neighbours particles when the distance is smaller than a certain threshold.
 The trail for the particles trajectories generates the tree graph.
\end_layout

\begin_layout Section
Technical background
\end_layout

\begin_layout Standard
Similar to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Rodkaev et al (2003)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:runions2007]{Runions et al (2007)}
\end_layout

\end_inset

 suggest a space colonization algorithm as an extension of the 3D leaves
 venation by Runion et al REFERENCE.
 Unlike Rodkaev, Runions branching structure is formed in a base-to-leaves
 order.
 Each iteration of the algorithm produces new elements that expand the tree
 structure formed in the previous steps.
 This approach results not only to be adaptive to obstacle and neighbour
 plants, but also provides controls over the growth process that results
 in a wide variety of tree structures.
\end_layout

\begin_layout Subsection
Overview
\begin_inset CommandInset label
LatexCommand label
name "subsec:Overview"

\end_inset


\end_layout

\begin_layout Standard
The algorithm proceeds as follows.
 A 3D envelope for the tree crown is specified as input.
 Its volume is seeded with a set of attraction points.
 The attraction points influence the growth of the tree structure by signalling
 the availability of empty space within the tree crown envelope.
 A single point is specified as input and acts as the base of the tree.
 Having the attracting points and the first tree point, the tree structure
 is generated as an iterative process.
 Each iteration produces new tree points in the direction of the neighbour
 attraction points to extend the existing tree structure.
 The algorithm may stop after a user defined number of iterations.
 If let running, the algorithm stops either when there are no attraction
 points within the radius of influence or when there are no attraction points
 left.
\end_layout

\begin_layout Standard
Further manipulation involves subdivision and smoothing of the internodes
 (branch that connects two consecutive nodes of the tree), skinning and
 scattering of organs such as leaves, flowers or fruits.
\end_layout

\begin_layout Subsection
Growth Algorithm
\begin_inset CommandInset label
LatexCommand label
name "subsec:Growth-Algorithm"

\end_inset


\end_layout

\begin_layout Standard
Competition for space plays a fundamental role in the colonization algorithm
 and determines the branching pattern for the tree structure.
 Before delving into the details of the algorithm some definitions and axioms
 are needed.
\end_layout

\begin_layout Subsubsection
Definitions and axioms
\end_layout

\begin_layout Enumerate
Every point the algorithm uses is either a tree node or an attraction node.
 From now on we will refer to tree nodes with 
\begin_inset Formula $v$
\end_inset

 and attraction nodes with 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $N$
\end_inset

 is the set of all the attraction points.
\begin_inset Formula 
\begin{equation}
\forall s,s\in N
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $T$
\end_inset

 is the set for the tree nodes
\begin_inset Formula 
\begin{equation}
\forall v,s\in N
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
If we refer to 
\begin_inset Formula $p$
\end_inset

 as a generic point in the algorithm
\begin_inset Formula 
\begin{equation}
\nexists p(p\in N\land p\in T)
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $S(v)$
\end_inset

 is the set of attraction points 
\begin_inset Formula $s$
\end_inset

 that influence the growth of the tree point 
\begin_inset Formula $v$
\end_inset

 for the current iteration.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $d(a,b)$
\end_inset

 is the Euler distance between point 
\begin_inset Formula $a$
\end_inset

 and point 
\begin_inset Formula $b$
\end_inset

 
\begin_inset Formula 
\begin{equation}
d(a,b)=\sqrt{(a.x-b.x)^{2}+(a.y-b.y)^{2}+(a.z-b.z)^{2}}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $di$
\end_inset

 is the 
\shape italic
radius of influence
\shape default
 which represents the maximum distance between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 so that 
\begin_inset Formula $s\in S(v)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $dk$
\end_inset

 is the 
\shape italic
kill distance
\shape default
.
 If 
\begin_inset Formula $d(s,v)$
\end_inset

 is less than 
\begin_inset Formula $dk$
\end_inset

, 
\begin_inset Formula $s$
\end_inset

 gets removed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $D$
\end_inset

 is the distance between consecutive nodes of the tree
\end_layout

\begin_layout Subsubsection
Steps
\begin_inset CommandInset label
LatexCommand label
name "subsec:Steps"

\end_inset


\end_layout

\begin_layout Enumerate
Define a 3D shape for the tree crown.
 Initialize the parameters N, di, dk, D.
\end_layout

\begin_layout Enumerate
Populate the 3D envelope with attraction points using a certain random distribut
ion.
\end_layout

\begin_layout Enumerate
Define at least one tree node to act as the base of the tree structure.
\end_layout

\begin_layout Enumerate
Each attraction point 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $s\in N$
\end_inset

, may influence the tree node 
\begin_inset Formula $v$
\end_inset

 that is closest to it.
 The influence occurs if 
\begin_inset Formula $d(s,v)<di$
\end_inset

.
 For each 
\begin_inset Formula $s\in N$
\end_inset

, check if there is any 
\begin_inset Formula $v\in T$
\end_inset

 that meets the condition.
 More than one attraction point may influence the same 
\begin_inset Formula $v$
\end_inset

 tree point: all the attraction points that influence 
\begin_inset Formula $v$
\end_inset

 are gathered in the 
\begin_inset Formula $S(v)$
\end_inset

 set.
\end_layout

\begin_layout Enumerate
For each tree node 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $v\in T$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
, if S(v) is not empty, a new tree node 
\begin_inset Formula $v^{\prime}$
\end_inset

is created.
 The new tree node lies at a distance 
\begin_inset Formula $D$
\end_inset

 from 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $v$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
 in the direction of the average of the normalized vectors towards the attractio
n points 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $s\in S(v)$
\end_inset


\begin_inset Formula 
\begin{equation}
v^{\prime}\in T
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
d(v,v^{\prime})=D\label{eq:newborn_dir_magnitude}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\vec{n}=\sum_{s\in S(v)}\frac{s-v}{\shortparallel s-v\shortparallel}\label{eq:newborn_dir}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\hat{n}=\frac{\vec{n}}{\shortparallel n\shortparallel}\label{eq:newborn_dir_normal}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
v^{\prime}=v+D\hat{n}\label{eq:newborn_position}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate

\lang english
perform a check to test, if any, attraction points 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $s\in N$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 should be removed if the following condition is true for at least one 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $v\in T$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
:
\begin_inset Formula 
\begin{equation}
d(s,v)<dk
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate

\lang english
repeat from steps 4 to 6 until we meet the stop conditions mentioned in
 HYPERREF!!!.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The network for the implementation of the growth algorithm relies on the
 layering of simple rules that eventually lead to the creation of the complexity
 that characterizes trees in nature.
 Houdini supports multiple scripting languages such as HScript, Python and
 VEX.
 Being Python widely used as scripting language and being a reality shared
 between many DCC software, it might seem the most sensible choice.
 On the other hand, VEX scripting language is Houdini native language.
 VEX gives direct access to geometry data and provides a wide variety of
 built-in function optimized for best performances on the Houdini geometry
 internal representation.
 In terms of performances, VEX has proven to be faster than Python because
 it implements automatic multithreading while Python does not have the same
 feature.
\end_layout

\begin_layout Subsection
Wrangle Node
\begin_inset CommandInset label
LatexCommand label
name "subsec:Wrangle-Node"

\end_inset


\end_layout

\begin_layout Standard
The wrangle node REFERENCEEEEE is the most present node type in the network
 therefore it seemed only natural to give a brief explanation of how it
 works.
\end_layout

\begin_layout Standard
METTICI UNA IMMAGINE The attribute wrangle is a low level node that allows
 for the tweaking of the geometry attributes using VEX code.
 Its capabilities correspond to the Attribute VOP SOP.
 The main difference between the two of them is that wrangle uses a a textual
 editor whilst the Attribute VOP SOP uses a visual network.
\end_layout

\begin_layout Standard
The node can edit the input geometry by changing or adding attributes.
 It can also remove or create new geometry for example by adding points,
 linking points together to create polygons and so on.
 The snippet runs on details or on every point/primitive/vertex of the first
 input geometry.
 Using the multiple sources to the node it is also possible to access data
 from different geometry at the same time.
 When having multiple sources, only the first input geometry will flow down
 to the next node of the network whilst the other input geometries will
 be lost.
\end_layout

\begin_layout Standard
When the snippet affects the attributes of the geometry, these attribute
 will not be available until the node is cooked.
 This often makes is difficult to populate geometry attributes such as array
 within the same wrangle node.
 Due to this, the implementation of particular parts of the growth algorithm
 might not seem the most straightforward or obvious way to approach the
 problem but have been deliberately tweaked to overcome this particular
 issue.
\end_layout

\begin_layout Subsection
Data structure
\begin_inset CommandInset label
LatexCommand label
name "subsec:Data-structure"

\end_inset


\end_layout

\begin_layout Standard
The growth algorithm, as presented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Growth-Algorithm"

\end_inset

, mostly relies on points position.
 Each point has certain attributes to make it possible to create the tree
 structure.
 The attribute @type divides the point set in two main categories respectively
 the tree nodes and the attraction points.
 Given the nature of the algorithm, the total number of attraction points
 will decrease each iteration whilst every new node that will be created
 will increase the count for the tree nodes.
 To give a better visualization for this partition, the colour attribute
 @Cd is initialized to {1, 0.5, 0} for the tree node and to {0, 0.5, 1} for
 the attraction points.
\end_layout

\begin_layout Standard
The aim of the algorithm is to create a believable branching structure to
 reproduce natural trees.
 Stems might grow in only one direction or fork producing new stems.
 Older stems also grow thicker to balance the weight of the younger stems.
 This branching pattern can be represented by an acyclic graph data structure.
\end_layout

\begin_layout Standard
A graph is a finite collection of vertices and edges.
 Graph are used to model pairwise relations between object.
 The vertices, or nodes, represent the objects while the edges are the relations.
 The different nature of the relations leads to different kinds of graphs.
 In the case of a directed graph, each edge has an orientation, from one
 vertex to another vertex.
 A path is a sequence of edges.
 A node A is reachable by another node B if there exists a path that leads
 from A to B.
 If for each node in the graph there is no path that connects the node to
 itself, the graph is said to be acyclic.
 Being a graph a hierarchical structure, it is appropriate to address relationsh
ip between nodes as parent/child relationship.
 Each node is therefore aware either of its parent, its children or both.
 In computer science, to reproduce the relationships between nodes, each
 node contains a pointer to the connected ones.
 The network developed for this project provides each tree node with two
 attributes an integer and an array to store references to the parent and
 the children respectively.
 Unfortunately Houdini does not have pointers like structures.
 The points of a geometry are stored in an array like structure.
 The @ptnum attribute refers to the index of the point in that array.
 When referring to a point using the @ptnum attribute, one can gain direct
 access to that points other attributes, either built in or custom.
 Unfortunately, being the @ptnum ultimately just an index in an array, its
 value is not consistent through the network.
 Operation such as adding or removing points or merging together two geometry
 may shift or offset the @ptnum value.
 Given its unstable nature, the @ptnum did not seem to be a suitable choice
 to build parent/child relation upon.
 As a workaround, each treepoint also stores a unique identifier @id.
 Smaller @id values belong to older tree points while greater values belong
 to younger ones.
 When populating the @parent and @kids attributes, the reference to the
 other points will not be represented by the @ptnum but by the @id instead.
 Having to rely on a custom attribute such as the @id automatically translate
 into losing the direct access granted by the @ptnum.
 This greatly affects the performances of the whole algorithm because in
 order to find a node with a specific @id, one has to cycle over each point
 of the geometry and check for a match.
 In order not to loose this convenient feature, every time the algorithm
 has to work on the tree nodes, the sort node is used to remap the @ptnum
 based on the @id value.
 This solution allows for a reliable hierarchy structure while maintaining
 speed of access.
\end_layout

\begin_layout Standard
Another important information about the tree nodes is the grow direction
 and the length of the internode.
 Storing this values make it possible for a later more detailed manipulation
 of branching angles.
 Each point therefore stores a @growdir attribute that holds the normalized
 growth vector that links the parent to the node point position.
\end_layout

\begin_layout Standard
As a final step, each node also has two flags respectively for death and
 fertility.
 While the fertility flag signals if the node can produce a child in the
 current iteration and can be therefore non fertile and fertile in two consecuti
ve iteration, when the death flag is set it determines an irreversible condition
 for the node.
 A node dies whenever it reaches the maximum amount of children or for degenerat
ed cases such as the position of the child node being coincident with its
 own position.
\end_layout

\begin_layout Standard
As the information needed on a per node basis are quite important in terms
 of quantities, whenever an attribute is not needed any longer, it is removed
 from the geometry.
\end_layout

\begin_layout Subsection
Parameter initialization
\end_layout

\begin_layout Standard
define the 3D envelop, user input, choice on how many iteration, D, Dk,
 Di scaling factor (manipulated through the generations).
 Root point input as just points or a user selected trunk.
 Explanation of the algorithm for just nodes, new chapter for user defined
 trunk and branches.
\end_layout

\begin_layout Standard
In order for the growth algorithm to start, some parameters have to be set
 such as the tree crown envelope, the attraction points position and the
 roots points.
\end_layout

\begin_layout Subsubsection
Tree crown
\end_layout

\begin_layout Standard
The network provides up to three different ways to specify the crown volume
 for the tree.
 All of them take as an input polygonal shapes that are later converted
 to volume.
 At its very basic implementation, the user specified tree crown is converted
 to a volume using the Isooffset node.
 The conversion result to be necessary in order to populate the crown tree
 volume with the attraction points.
 Moving from the base implementation, the user can specify a collision object
 for the tree crown to interact width.
 This options makes it possible to simulate a tree growth process where
 the final shape is affected by the surrounding obstacles.
 The collision object is then converted to a volume.
 To identify the viable area for the tree to grow, the volume mix node performs
 the subtraction operation between the two input volumes.
 The resulting volume is then used for the tree to grow.
 Another option allows the user to specify not the crown tree volume directly
 but calculates the viable space for growth from a given object.
 The input geometry is converted to volume twice: the first conversion replicate
s the input geometry closely whilst the second one will inflate the volume
 with a user defined offset.
 The difference between the volumes will create a layer wrapped around the
 initial object.
 This option can convey the illusion of a plant clinging and growing finding
 support on an object, like vines do.
\end_layout

\begin_layout Standard
Unfortunately the conversion from polygon to volume can produce artefacts
 due to the conversion method used by the Isooffset node.
 Different workarounds to this problem have been tried but none of them
 proved to be successful for all kinds of input geometry.
 IMMAGINE DEL PROBLEMA
\end_layout

\begin_layout Subsubsection
Attraction Points
\end_layout

\begin_layout Standard
At early stages of the production, the volume obtained from the tree crown
 shape was seeded with points with a uniform distribution.
 The resulting trees, as described by Runion (REFERENCEEEEE) shows a uniform
 density in the branches distribution.
 In many trees and shrubs however, the density increases near the crown
 surface due to better light exposure.
 To achieve the same result, following Runion suggestion, the network implements
 a custom scattering distribution.
 As a first step, the tree crown is still seeded with attraction points
 using a uniform distribution.
 A wrangle node 
\begin_inset Quotes eld
\end_inset

distance_from_bounding_object
\begin_inset Quotes erd
\end_inset

 evaluates, for each attraction point, the distance from the bounding object
 provided as a second input to the node.
 The resulting value is stored to an attribute named @dist.
 The promote Houdini node is used twice to find respectively the maximum
 distance @max_dist and the minimum distance @min_dist for the @dist attribute.
 These information feed a second wrangle node 
\begin_inset Quotes eld
\end_inset

radial_distribution
\begin_inset Quotes erd
\end_inset

: each node @dist value is taken from its original range (@min_dist, @max_dist)
 and shifted to its corresponding value in the new range (0, 1).
 The resulting variable is linked to a user customizable ramp.
 The value from the ramp represents the probability for the attraction point
 to survive.
 A random number based on the @ptnum of the current attraction point is
 calculated and compared to the probability value.
 If it results to be less, the attraction point gets removed.
 The ramp extends the potential of Runion idea by giving the users not only
 control over the density near the crown surface but providing them with
 a greater art directability over the branches density from the centroid
 of the shape to its boundaries.
\end_layout

\begin_layout Standard
The same principles are used to define a second custom distribution that
 uses the Y coordinate of the point position is used instead of the distance
 from the object (
\begin_inset Quotes eld
\end_inset

AP_height
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

vertical_distribution
\begin_inset Quotes erd
\end_inset

).
 The newly generated attraction points are then initialized.
 
\end_layout

\begin_layout Subsubsection
Roots
\begin_inset CommandInset label
LatexCommand label
name "subsec:Roots"

\end_inset


\end_layout

\begin_layout Standard
The network provides three different ways to specify the roots for the growth
 algorithm.
 An user can either create single root points by specifying the coordinates,
 input a premade set of points or a trunk and branches curves structure.
\end_layout

\begin_layout Standard
For the first two option the initialization of the nodes attributes follows
 the same process.
 All the root points @parent is set to -1 to signal that they do not have
 any parent.
 As said before, the colour @Cd is initialized to yellow {1, 0.5, 0} and
 the @kids is declared as an empty array, the @type to 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

.
 Space will be allocated for for the @growdir @n_dead and @attr_dead.
 The initial values for these parameters are respectively {0, 0, 0}, 0 meaning
 that the node is alive and -1 to signal a default value.
\end_layout

\begin_layout Standard
The initialization of some attributes such as @parent, @kids and @type differs
 in the case of a custom trunk structure is fed in the system.
 This kind of structure already contains primitive information that link
 together points in a precise hierarchy.
 The most likely scenario is that each branch is represented as a curve
 primitive.
 The fork points of the structure will then belong to two different primitive
 at once, for example to both the trunk and a branch.
 The first attribute to be initialized is the @kids array using the 
\begin_inset Quotes eld
\end_inset

trunk_kids
\begin_inset Quotes erd
\end_inset

 snippet.
 This wrangle node is encapsulated in a for loop nodes block that will iterate
 on each primitive of the input geometry.
 The wrangle will therefore process the points of one primitive at the time.
 In the wrangle interface, the snippet is set to run over details so that
 the iteration process over the points is explicitly declared in in the
 code.
 The snippet starts by retrieving an ordered array of the current primitive
 points.
 A for loop then iterates over this array reading the point value and assigning
 the next point in the array to itself as @kids element.
 By using this approach, the snippet successfully handles specific cases
 in which the children to the point belong to different primitives.
 After having initialized the @kids attribute, the @parent comes straightforward
: the 
\begin_inset Quotes eld
\end_inset

trunk_parent
\begin_inset Quotes erd
\end_inset

 wrangle iterates over each point of the input geometry regardless the primitive
 they belong to.
 Each point will read its own @kids list and proceeds to set itself as @parent
 attribute to these points.
 One can refer to this process as parent injection.
 It is important to highlight that at this stage the @id attribute described
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Data-structure"

\end_inset

 has still not been initialized.
 The parent-children relation is built on the @ptnum.
 It is also important to understand that in this particular part of the
 network all the geometry being processed belongs to the tree structure.
 The @id can be therefore initialized as a plain copy of the @ptnum.
 Being @ptnum and @id coincident at this stage, the initialization process
 described results to be correct.
 As a next step, the @type has to be set.
 The implementation process makes sure that the user is given a certain
 extent of controls over the choice of root points for the growth algorithm.
 The network highlights as candidate roots all the points contained within
 the volume of the tree crown shape.
 The user can then decide which of them to keep.
 For the selected points, the @type is set to 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

 while the remaining ones are set to 
\begin_inset Quotes eld
\end_inset

trunk
\begin_inset Quotes erd
\end_inset

.
 During the growth algorithm, only the nodes will interact while the others
 will be lifeless.
 A final attribute @generation is initialized for all root points regardless
 whether they are single points or points being selected from a custom structure.
 This attribute plays a key role in a later part of the network to set and
 scale the cross section of the branches according to their age.
\end_layout

\begin_layout Subsection
Growth
\end_layout

\begin_layout Standard
The growth main algorithm lies inside a dedicated subnetwork 
\begin_inset Quotes eld
\end_inset

growing_alg
\begin_inset Quotes erd
\end_inset

.
 This subnetwork mainly consists of a for loop that determines the number
 of time the geometry is processed.
 Contrary to the stop conditions presented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Overview"

\end_inset

, the loop will only terminate after an user defined number of iterations.
 It can happen that the user require the algorithm to run more times than
 the ones required to meet the stop condition.
 In this case, even though the network will continue iterating, no new geometry
 is created.
 When running the algorithm, the user has also control over the values for
 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $dk$
\end_inset

 and 
\begin_inset Formula $di$
\end_inset

.
\end_layout

\begin_layout Standard
Before delving in the growth loop, the wrangle 
\begin_inset Quotes eld
\end_inset

AD_treepts
\begin_inset Quotes erd
\end_inset

 sets a detail attribute over the geometry that specifies the total number
 of treepoints based on the @type attribute of the points.
 This is later used to produce the @id for the new born nodes.
\end_layout

\begin_layout Standard
At this stage as well, points with type 
\begin_inset Quotes eld
\end_inset

trunk
\begin_inset Quotes erd
\end_inset

 are filtered out of the growth process and rejoined with the rest of the
 geometry when the process ends.
\end_layout

\begin_layout Subsubsection
Finding neighbours
\begin_inset CommandInset label
LatexCommand label
name "subsec:Finding-neighbours"

\end_inset


\end_layout

\begin_layout Standard
The nodes and the attraction points are divided based on the @type value.
 In order to keep the calculation as light as possible, a preparation step
 is undertaken using the 
\begin_inset Quotes eld
\end_inset

find_influencing_attr
\begin_inset Quotes erd
\end_inset

 before finding the closest tree node of each attraction point.
 The wrangle receives as first input geometry the set 
\begin_inset Formula $N$
\end_inset

 of the attraction points and as second input the set 
\begin_inset Formula $T$
\end_inset

 of tree nodes.
 The node purpose is to isolate the attraction points that will influence
 the tree growth for the current iteration from the inert ones.
 The snippet is set to run over details.
 Iterating over each tree node, a function _setInfluencing() is invoked.
 The function takes as an input a the position of the tree node.
 Based on that position, the function retrieves all the attraction points
 that are closer than the user defined 
\begin_inset Formula $di$
\end_inset

 distance.
 Every attraction point that satisfies this condition is flagged as influence
 node.
 The set of influence node is therefore a subset of the set 
\begin_inset Formula $N$
\end_inset

 of all the attraction points.
 Using the blast node, the influencing nodes are separated from the other
 inactive attraction points.
 The tree nodes and the influencing nodes are wired into the 
\begin_inset Quotes eld
\end_inset

find_neighbour
\begin_inset Quotes erd
\end_inset

 subnetwork.
 The search for the closest tree node is implemented in 
\begin_inset Quotes eld
\end_inset

fast_search
\begin_inset Quotes erd
\end_inset

: the wrangle takes as first input geometry the tree nodes and as a second
 input geometry the influencing points.
 At this stage not only each influencing point will look for its closest
 tree point but the sets 
\begin_inset Formula $S(v)$
\end_inset

 are populated as well.
 In this implementation the set is stored as a tree node array attribute
 @nbrs and will contain the @ptnum for all the influencing points for which
 the node is the closest of the tree nodes.
 This operation can be computationally heavy, therefore the following algorithm
 has been developed aiming to optimize such operations.
 The algorithm is divided in three parts:
\end_layout

\begin_layout Itemize
an array closest[] is declared to have the same size as the total count
 of influencing points.
 Starting from the index 0, the influencing point with @ptnum 0 is processed.
 The point will search for the closest tree node and will store its value
 in the array.
 The process moves to index 1 and processes the influencing point with @ptnum
 1 and so on until the closest[] array is completely populated.
 Given the population process, the indices of the closest[] array represent
 the influencing points.
\end_layout

\begin_layout Itemize
two new array are created:
\end_layout

\begin_deeper
\begin_layout Itemize
the argsort function applied to the closest[] array will return a list of
 indices that, if applied to the closest[] will give a sorted sequence in
 an increasing order.
 In this particular case, the indices represent the influencing points.
 The newly created ordered_attr[] array holds therefore a sorted sequence
 for the influencing points.
\end_layout

\begin_layout Itemize
the sort function applied to the closest[] will return a sorted array in
 increasing order.
 This new array is the ordered_closest[]
\end_layout

\end_deeper
\begin_layout Itemize
using the newly created arrays, the algorithm proceeds to locate the sets
 S(v) and store them in the proper tree nodes.
 The sets are consecutive chunks of the ordered_attr[] array.
 To tokenize it properly, the ordered_closest[] is used.
 A for loop iterates over the length of the array.
 The value of ordered_attr[i] is stored in a new temporary array nbrs[].
 A check is performed to compare the current element for ordered_closest
 and its consecutive one.
 It the two do not match, it means that the end of the current set S(v)
 has been reached.
 The temporary array is assigned as @nbrs attribute to the tree node specified
 in ordered_closest[i].
 The temporary array is cleared for the next set.
\end_layout

\begin_layout Standard
The algorithm proved to be dramatically faster compared to its basic implementat
ion.
 The reader can compare the performances by switching the input for the
 switch node in the 
\begin_inset Quotes eld
\end_inset

grow_alg/find_neighbour
\begin_inset Quotes erd
\end_inset

 subnetwork.
 The approach undertaken here also improved Runion algorithm by reducing
 the number of computation required to achieve the result.
 IMMAGINE ALGORITMO, IMMAGINE NETWORK
\end_layout

\begin_layout Subsubsection
Set fertility for the tree nodes
\end_layout

\begin_layout Standard
Extending Runion's algorithm further, the user can specify the maximum count
 of branches that a node can generate and from which generation the nodes
 can begin the branching process.
 This node gives a better control over the final tree structure as it allows
 to achieve a sparser result when reducing the count of children per node.
 By choosing the generation from which to start branching, the user can
 enhance the visual impact of the main trunk structure.
 The wrangle 
\begin_inset Quotes eld
\end_inset

set_fertility
\begin_inset Quotes erd
\end_inset

 operates over this constraints: the eligible nodes for the production of
 a new tree node are flagged as fertile.
 Another check is here performed: in the case the node has already reached
 the maximum count of children allowed, the node is flagged as dead and
 becomes inactive for all the remaining iterations of the growth algorithm.
\end_layout

\begin_layout Subsubsection
Calculate new born direction
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

newborn_dir
\begin_inset Quotes erd
\end_inset

 wrangle runs over each tree point that is fed as a first input geometry.
 If the node results to be fertile, the snippet proceeds to retrieve the
 identifiers of the influencing points to that tree node stored in the @nbrs
 array attribute.
 The set of all the influencing points is fed to the wrangle as a second
 input geometry.
 Having the identifiers for the influencing points and the influencing points
 geometry as input, the algorithm can use the identifiers as lookup keys
 to retrieve the position of the influencing points.
 The growth direction for the future newborn is then calculated using 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:newborn_dir"

\end_inset

.
 The normalized 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:newborn_dir_normal"

\end_inset

 result is stored in the vector attribute @dir of the tree node.
 This way, the parent node is in charge of holding all the information needed
 to later create and initialize correctly the new born nodes.
 Before moving on to the next step of the network, the snippet checks for
 degenerated cases for which the magnitude of the @dir vector is 0, which
 happens whenever the @nbrs list of influencing points is empty.
 These nodes are declared dead and their fertility flag reset to 0.
\end_layout

\begin_layout Subsubsection
Creation of the new node
\begin_inset CommandInset label
LatexCommand label
name "subsec:Creation-of-the-new-node"

\end_inset


\end_layout

\begin_layout Standard
At this stage, the network has gathered all the information needed to create
 the new generation of tree nodes.
 The wrangle 
\begin_inset Quotes eld
\end_inset

create_new_node
\begin_inset Quotes erd
\end_inset

 runs over each fertile node of the tree structure.
 The position of the new tree node is determined and the point created using
 the addpoint() Houdini VEX function.
 The _initializeAttribute() function is then invoked to take care of all
 the parameters of the new born that will make it a viable new tree node.
 The function takes as parameters the @ptnum of the newborn and the @ptnum,
 @dir and @gen of the parent node.
 With these information it proceeds populating the attributes for the newborn
 as described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Initialization-of-newborn"

\end_inset

 
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Initialization of newborn tree node
\begin_inset CommandInset label
LatexCommand label
name "alg:Initialization-of-newborn"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

attr_dead = -1;
\end_layout

\begin_layout Plain Layout

Cd = {0, 1, 0};
\end_layout

\begin_layout Plain Layout

fertile = 0;
\end_layout

\begin_layout Plain Layout

generation = parent_generation + 1;
\end_layout

\begin_layout Plain Layout

growdir = parent_dir;
\end_layout

\begin_layout Plain Layout

n_dead = 0;
\end_layout

\begin_layout Plain Layout

parent = parent_id;
\end_layout

\begin_layout Plain Layout

type = "node";
\end_layout

\begin_layout Plain Layout

id = -1;
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The colour is initialized as green because the new node does not have any
 children yet.
 This information is later used in the network to find the points on which
 to scatter leaves.
 The @id is temporarily set to a default value and set to its proper value
 later on in the network.
 Compared to Runion's algorithm, the project offers a new approach.
 The original algorithm kept the distance D between consecutive tree nodes
 as a constant, in nature, though, younger shrubs grow shorter than the
 previous ones.
 In an attempt to reproduce this natural phenomena, this projects implements
 a scaling algorithm that progressively reduces the D length value across
 generations.
 The scaling factor is represented as a ramp that the user can manipulate
 to achieve the desired look.
\end_layout

\begin_layout Standard
To set the newborns id correctly, these points are separated from the other
 tree nodes.
 To set the @id, the network relies on the total count of tree points as
 showed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Set-newborn-id"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Set newborn id
\begin_inset CommandInset label
LatexCommand label
name "alg:Set-newborn-id"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

foreach newborn
\end_layout

\begin_layout Plain Layout

	id = treepointcount + current iteration value
\end_layout

\begin_layout Plain Layout

	update treepoint count as treepointcount + 1
\end_layout

\end_inset


\end_layout

\end_inset

The reason behind this particular implementation can be found in the peculiar
 nature of the Houdini wrangle nodes.
 The geometry the snippet can access is only the one that is wired in as
 input to the node.
 As explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Wrangle-Node"

\end_inset

, any changes the snippet produces to the geometry will not be reflected
 on the geometry until the node is cooked and fed as input to the next node
 in the network.
 Following this logic, the update of the tree point count, even if it get
 changed every iteration, will only be written on the geometry when the
 snippet has iterated over all the points.
 The tree point count value used to assign the new id is therefore the same
 for each newborn.
\end_layout

\begin_layout Standard
As a final step, the parents @kid list attribute has to be updated with
 the newborns @id.
 The separated tree nodes are fed as first input geometry to the 
\begin_inset Quotes eld
\end_inset

update_parent
\begin_inset Quotes erd
\end_inset

 wrangle.
 The wrangle will also take as a second input geometry the newborn points.
 For each of the newborns, the snippet will retrieve the @parent id value.
 Given the parent @id, the _findPt() function returns the a handle to the
 parent node for which the currently processed newborn is appended to the
 list of children.
 Since the parent now has at least one child, its colour is set to yellow.
 To speed up the performances further, the old tree points are divided further
 so that only the fertile ones, therefore the parents, are fed in the 
\begin_inset Quotes eld
\end_inset

update_parent
\begin_inset Quotes erd
\end_inset

 wrangle.
\end_layout

\begin_layout Standard
Once this setup is completed, the tree nodes are joined back together.
\end_layout

\begin_layout Subsubsection
Remove attraction points
\end_layout

\begin_layout Standard
As a final step of the growth algorithm, as described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Steps"

\end_inset

, the network has to remove the attraction points that are closer to the
 tree points than the kill distance 
\begin_inset Formula $dk$
\end_inset

.
 Runion explains that greater values for this parameter yield to increasingly
 sparse crowns.
 In his algorithm, the 
\begin_inset Formula $dk$
\end_inset

 is a constant of the whole groth process.
 The tree branching structure presented in his research always result to
 be too sparse when it comes to small twigs closer to the tree crown shape.
 In an attempt to improve the appearance of such small twigs, the algorithm
 presented in this project scales the value for 
\begin_inset Formula $dk$
\end_inset

 based on a ramp.
 The user can therefore manipulate its value and decrease it for younger
 twigs to achieve better density and more details near the crown surface.
\end_layout

\begin_layout Subsubsection
Preparation to next iteration
\end_layout

\begin_layout Standard
Some attributes of the tree nodes have to be reset to default values in
 order for the next iteration to start in a clean state.
\end_layout

\begin_layout Itemize
@dir is set back to {0, 0, 0}
\end_layout

\begin_layout Itemize
@nbrs is emptied
\end_layout

\begin_layout Itemize
@fertile flag is set to 0
\end_layout

\begin_layout Subsubsection
Extra controls
\begin_inset CommandInset label
LatexCommand label
name "subsec:Extra-controls"

\end_inset


\end_layout

\begin_layout Standard
Even though the overall algorithm can produce a wide range of different
 branching structures, the project provides some controls:
\end_layout

\begin_layout Itemize
pruning probability: starting from a user defined generation and killing
 probability threshold value, a random number is calculated for each tree
 point and compared to the killing probability.
 If the random number is smaller than the threshold, the node is set to
 non fertile.
 This small check gives more controls over the density of the branches.
\end_layout

\begin_layout Itemize
pruning by distance: the user can define a minimum distance from the tree
 crown geometry.
 Whenever the distance of a tree point from the crown shape is less than
 that value, the node is set to dead.
\end_layout

\begin_layout Itemize
fix growing angles: it may happen that siblings branches grow too close
 one to each other.
 A new control checks the angle between siblings branches and modifies the
 younger sibling position if the angle is less than the specified threshold.
 
\end_layout

\begin_layout Subsection
Linking the points
\end_layout

\begin_layout Standard
The relationship between parent and children created during the creation
 of new points makes it trivial to link the point together to create the
 tree skeleton.
 The wrangle 
\begin_inset Quotes eld
\end_inset

connect_points
\begin_inset Quotes erd
\end_inset

 fetches for each point its parent.
 Using the addprim() VEX function a new empty primitive is created.
 The two points are added to that primitive and the link between them is
 created.
\end_layout

\begin_layout Subsection
Cross section evaluation
\begin_inset CommandInset label
LatexCommand label
name "subsec:Cross-section-evaluation"

\end_inset


\end_layout

\begin_layout Standard
In order to create a polygonal mesh around the tree skeleton, the cross
 section has to be evaluated on a per point basis.
 The network implements two different algorithm to fulfil this purpose.
\end_layout

\begin_layout Subsubsection
Ramp scale
\end_layout

\begin_layout Standard
The user is provided with a ramp and a multiplier slider.
 The multiplier scales the amplitude for the ramp while the curve on the
 ramp represent the scaling factor for each generation of tree points.
 The 
\begin_inset Quotes eld
\end_inset

ramp_scale
\begin_inset Quotes erd
\end_inset

 relies on the fit() function to convert the generation value for the current
 point to a value in the range (0, 1).
 The new width is then computed as the product between the ramp value and
 the multiplier.
\end_layout

\begin_layout Subsubsection
Eulerian Scale
\end_layout

\begin_layout Standard
In his research, Runion relies on FIND REFERENCE to determine the cross-section
 of the limbs.
 In this model, known as Eulerian Scale CHECK!!!!, the diameter of a limb
 below a branching point is determined by the combined cross-section of
 the limbs above.
 The process assumes that all tip points share the same radius r0 and proceeds
 assigning the radii for the other points from the tip branches towards
 the tree base.
 When two branches with different radius r1, r2 join in a branching point,
 the radius r of the supporting limb is given by 
\begin_inset Formula $r^{n}=r_{1}^{n}+r_{2}^{n}$
\end_inset

 where n varies between 2 and 3.
 This implementation, however, tries to implement the same main formula
 by processing the tree limbs from the root to the tip branches.
 The user can choose the initial value for the root thickness.
 Having the first node width set, the algorithm iterates over every point,
 in order, finding the children of the node and setting the width on them
 based on its own width and the total count of children.
 This approach works in this specific implementation because the tree points
 have been created in order with increasing @id numbers.
 Therefore, when iterating on them, it never happens that the node does
 not find its own width to be already set by a previous node.
 Once again, the nature for the wrangle node does not allow to easily propagate
 the width from parents to children due to the cooking and updating issue
 explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Wrangle-Node"

\end_inset

.
 To overcome this problem, the wrangle node only processes one point at
 the time while the iteration is implemented with the loop blocks native
 in Houdini.
 Since the blocks are in charge of the iteration, the wrangle gets cooked
 and the geometry updated.
\end_layout

\begin_layout Subsubsection
Special case: trunk
\end_layout

\begin_layout Standard
For a custom trunk input the original ramp algorithm cannot be used as the
 scaling factor is calculated based on the generation number populated during
 the growth algorithm.
 Unfortunately, the trunk points do not have a generation to rely onto.
 Furthermore, the user might want to have a better control over the main
 branches structure as they play a key role in the final appearance of the
 tree.
 As a consequence, the network first sets the width for the trunk and on
 a later stage takes care of the smaller branches generated by the growth
 algorithm.
 The trunk structure is fetched again from its original source.
\end_layout

\begin_layout Standard
As for initializing the @kids attribute as discussed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Roots"

\end_inset

 the wrangle node works on the points of each primitive at the time.
 The Houdini loop blocks are in charge of iterating over the primitives
 of the trunk structure.
 The wrangle creates a ramp and a multiplier for the user to manipulate
 the width at will.
 Before assigning the width value, a control is performed to check what
 is the @width value for the first point of the primitive.
 If the @width value is -1 (the default one), the primitive being processed
 is the main trunk.
 The algorithm can assign the width for the next points of the primitive
 simply by multiplying the ramp value and the multiplier factor.
 If the @width is different than -1, the primitive represents a secondary
 branch and its first point is the branching joint between the current branch
 and its supporting limb.
 Its width is therefore been already set as part of the oother branch.
 To blend one branch into its secondary one, the next nodes in the primitive
 are set similarly to the main trunk except that the user defined multiplier
 is substituted by the first node width.
\end_layout

\begin_layout Standard
As next step the width for the branches generated by the growth algorithm
 has to be set.
 For the ramp scale, the main idea of the artistic directable ramp is maintained
 although blending the branches with the trunk structure requires some further
 manipulation.
 If for the previous case all the root points shared the same user defined
 width, in this case the width of each node acting as a root has already
 been set.
 The initial condition for this algorithm is represented by a set of tree
 structures for which the roots are the trunk points.
 Each tree has to scale the width of the branches according to the ramp
 but each of them should use the width of its own root point as a multiplier
 to achieve the desired blending effect.
 This is textbook for recursive algorithm: ideally one should iterate on
 each child of the root and set the width.
 Each child then acts as root of its own sub-tree and the operation repeated.
 Unfortunately Houdini VEX does not support recursive function calls at
 the current time.
 The algorithm has therefore been converted from recursive to iterative
 by using a stack data structure as a support.
 The root node stores its children in the stack.
 A while loop iterates over the stack.
 For each iteration, the last added node is removed from the stack and is
 processed.
 After setting its own @width value, the node pushes its children in the
 stack and a new iteration begins.
 The while loop only stops when the stack is empty.
 Using the stack as support data structure, the described process successfully
 simulates a depth first recursive algorithm and overcomes the updating
 geometry problem explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Wrangle-Node"

\end_inset

.
\end_layout

\begin_layout Subsection
Trunk Skinning
\end_layout

\begin_layout Standard
After building the tree structure, each branch is re-sampled to gain more
 control over the final look.
 The point jitter SOP helps moving from straight branches curves to a more
 gnarly and varied silhouette.
 Its effect gets easily out of control causing the geometry to change too
 drastically.
 To counterbalance the sharp angles generated by the jitter, the smooth
 SOP inteerpolates these angles and achieve a more natural look.
 The polywire SOP creates the polygonal mesh around the tree skeleton using
 the @width attribute set in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Cross-section-evaluation"

\end_inset

 as cross-section value.
 A second smooth SOP interpolates the thickness values at the branching
 nodes.
 As a final step, the user can decide whether to color the trunk with a
 color SOP or input a custom shader.
\end_layout

\begin_layout Subsection
Leaves
\end_layout

\begin_layout Standard
In nature, trees produce leaves only on the very ending points of the branching
 structure.
 To replicate this phenomena the network isolates all those point of the
 tree who do not have any children.
 The leaves are then copied on those points by using the copy_stamp node.
 For the copy_stamp to work properly, the normal direction has to be set
 for the tree points.
 The point SOP activates an edge force on these point.
 The edge force is directed along the edge direction which is stored in
 the 
\family typewriter
edge_dir
\family default
 built in variable for points in Houdini.
 With a VOP subnetwork the 
\family typewriter
edge_dir
\family default
 is copied as value for the normal direction of the points.
\end_layout

\begin_layout Standard
The user can decide to either use the default geometry or to input a custom
 model for the leaves.
 For the default ones, some copy_stamping expression randomizes the roll
 and pitch within a certain range of values on a per instance basis.
 For the custom geometry instead, a control is given to specify the number
 of leaves per tree point.
 The copy_and_transform evenly spreads the leaves radially by dividing 360
 degrees of the number of leaf instances specified by the user.
\end_layout

\begin_layout Standard
The user can choose whether to use a plain color or apply a custom shader.
 While the default geometry is ready to shade, the user has to make sure
 to prepare the custom geometry for the shading process using the UV_project
 Houdini node before feeding the leaf object as input to the network.
\end_layout

\begin_layout Section
Problems and attempted solutions
\end_layout

\begin_layout Subsection
Determine S(v) set
\end_layout

\begin_layout Standard
At very early stages of production, the 
\begin_inset Formula $S(v)$
\end_inset

 set has been implemented as a Houdini group.
 Groups in Houdini are similar to a boolean variable associated to each
 point of the geometry that specifies the membership of the point to the
 group.
 Having n tree nodes, the system would have to store n groups.
 After a few couple of iteration however, the number of different groups
 resulted to be inefficient to use.
 At this stage as well, the sets were processed in a for_each subnetwork
 that unfortunately caused issues of duplicated geometry which lead to frequent
 crashes of the scene.
 As a solution, the current data system relying on the attribute @nbrs instead
 of the groups was adopted.
\end_layout

\begin_layout Subsection
Branching collisions
\end_layout

\begin_layout Standard
For some cases, especially for the very first generations, it may happen
 that branches tend to grow too clustered together.
 The 
\family typewriter
fix_newborn_dir
\family default
, as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Extra-controls"

\end_inset

, takes care of these particular scenarios moving the newborn to a minimum
 distance angle from its closest sibling.
 To achieve this result, the algorithm presented in CROSSREF ALLA APPENDIX
 was used.
\end_layout

\begin_layout Subsubsection
IsoOffset: from polygons to volumes
\end_layout

\begin_layout Standard
The IsoOffset node converts the user input crown shape to a volume that
 can be seeded with attraction points.
 Unfortunately the conversion leads to some artefacts such as horizontal
 lines exceeding or carving the original geometry.
 Different solution have been tried such as changing the volume conversion
 method but none of them proved to be succesfull for more than a few cases.
\end_layout

\begin_layout Subsubsection
Scaling
\end_layout

\begin_layout Standard
As it concerned the Eulerian scaling system, the newly proposed approach,
 even though it results easier to implement, can lead to chopped branches.
 Starting from the roots and proceding to the top from a user defined initial
 width value, whenever a branch dies due to the lack of space or the pruning
 system, it looks truncated.
 Similar issue arises for the ramp scaling system.
 Again, if a branch dies in an early generation, its width will be the same
 as the other branches that kept scaling down along the new generated branches.
\end_layout

\begin_layout Standard
A solution may be found for the first algorithm with a careful manipulation
 of the tree points to process them backwards from the tips to the root
 as suggested originally by Runion.
 Such solution would most likely not work properly for a custom trunk with
 custom thickness.
 The blending between automatically generated branches and user input ones
 would probably have to be achieved manually.
 As far as it concerns the ramp scale, a solution could not be found during
 this project and the problem remains open for future work.
\end_layout

\begin_layout Section
Performances
\end_layout

\begin_layout Standard
An iterative system that handles huge amount of geometry can result to be
 considerately slow.
 Even though the performances were not the primary focus of this project,
 a considerable effort has been made to make the network as fast as possible.
 The reason for investing in the performances relies in the nature of the
 tool.
 The project presented aims to be an easy and quick to setup tool to create
 procedural and art-directable trees.
 If the tool were to require several minutes to produce a result, the user
 will find it hard to compare two successive attempts at tuning the parameters
 to get the desired look.
 At very early stages of development, cooking a 30 iteration tree took up
 to 40 minutes.
 Dividing the geometry throughout the space colonization algorithm between
 nodes and attraction points helped speeding up the execution time.
\end_layout

\begin_layout Standard
Even tough this change improved the performances, the network still spent
 an excessive amount of time processing the find_neighbours 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Finding-neighbours"

\end_inset

 algorithm and the setting id process 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Creation-of-the-new-node"

\end_inset

.
 Dividing the tree points respectively between newborns, parents and old
 tree nodes improved the performances dramatically since the search loop
 was only to iterate over a few hundred points instead of a few thousand.
\end_layout

\begin_layout Standard
As a final speedup, the original algorithm for the search of neighbour dragged
 down the overall performances of the network because, in order to update
 the geometry, it cooked the same node over 20 thousand times per iteration
 of the growth algorithm.
 The new approach presented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Finding-neighbours"

\end_inset

 made the real difference in terms of the final execution time.
\end_layout

\begin_layout Standard
Even though the execution time still heavily depends on parameters such
 as the total number of attraction points, iterations, 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $di$
\end_inset

, 
\begin_inset Formula $dk$
\end_inset

, the average cooking time stabilized around 15 s for 40 iteration trees.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
The described implementation successfully reproduces the approach presented
 by Runions.
 The volume of the tree crown is represented as a set of attraction points
 which get removed as the branches approach them.
 Parameters specify the granularity of the empty space, the search distance
 from which the branches can sense it and how deep the empty space sensed
 can be penetrated by the branches.
 Further controls manipulate the distribution of the attraction points allowing
 for a greater density of branches near the surface of the tree crown.
 Information of the hierarchy of branches offers control over their different
 sizes.
 The final result produced a realistic branching structure even without
 any post processing of the skeleton.
 In some cases, post processing operations such as resampling the branches
 or applying random noise to the tree points leads to a more natural look
 of the final artefact.
 The project builds on Runion's research to add more controls over the branching
 structure by varying the parameters value on the fly and introducing small
 correction such as the pruning system and the angle correction.
 A fully art-directable scaling system for the branch size has been developed
 alongside the one proposed in the original paper.
\end_layout

\begin_layout Standard
The tool successfully integrates a user defined main skeleton with the geometry
 produced by the space colonization algorithm fulfilling the purpose of
 having a tool for art-directable procedural vegetation.
 The implementation also proved to be able to handle a wide range of scenario:
 it can grow trees from one or multiple sources at once, a custom trunk
 can be sued as starting point for the space colonization algorithm, the
 generated geometry reacts to the surrounding obstacles either avoiding
 them or using them as objects to crawl onto in a vines like behaviour.
 When tested for rendering, the produced mesh unwraps correctly.
\end_layout

\begin_layout Subsection
Future work
\end_layout

\begin_layout Standard
The system successfully simulates the competition for space that characterizes
 tree structures.
 As future enhancement, competition for light could be introduced as well.
 The light influence could probably solve the issue of having a too sparse
 foliage.
 To address the same problem, the system could use a proxy or billboards
 instead of actual geometry that expands only at render time.
 That would maintain the scene responsive while improving the final look.
\end_layout

\begin_layout Standard
Other problems remain pleasantly open for future research.
 The method proposed in this project creates a believable mature tree.
 The project could be significantly improved by being able to simulate the
 growth process that leads from young shrubs to the mature tree.
\end_layout

\begin_layout Standard
A simulation of breeze through the leaves or wind interacting with the tree
 would improve the overall result and could be accomplished using the Houdini
 wire solver.
\end_layout

\begin_layout Standard
For scene populated by a large number of plants, the current geometry might
 be too heavy.
 Implementing a procedural LOD for the polygonal mesh and an automatic pruning
 of the small twigs based on the distance prom the camera could make the
 viewport more responsive and the rendering quicker.
\end_layout

\begin_layout Part*
Appendix
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{part}{Appendix}
\end_layout

\end_inset


\end_layout

\begin_layout Section*
L-System
\end_layout

\begin_layout Standard
Lindenmayer systems — or L-systems for short — were conceived as a mathematical
 theory of plant development [82].The central concept of L-systems is that
 of rewriting.
 In general, rewriting is a technique for defining complex objects by successive
ly replacing parts of a simple initial object using a set of rewriting rules
 or productions
\end_layout

\begin_layout Section*
Fractals
\begin_inset CommandInset label
LatexCommand label
name "sec:Fractals-(100-words)"

\end_inset


\end_layout

\begin_layout Standard
The term 
\begin_inset Quotes eld
\end_inset

fractal
\begin_inset Quotes erd
\end_inset

 derives from the latin 
\emph on
fractus
\emph default
, which means 
\begin_inset Quotes eld
\end_inset

broken
\begin_inset Quotes erd
\end_inset

.
 The word was firstly introduced by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:Mendelbrot1982]{Mandelbrot (1982)}
\end_layout

\end_inset

.
 In Mandelbrot's words, a fractal is 
\end_layout

\begin_layout Quote
a rough or fragmented geometric shape that can be split into parts, each
 of which is (at least approximately) a reduced-size copy of the whole
\end_layout

\begin_layout Standard
The definition can be therefore divided such as follows to emphasise the
 main features of a fractal:
\end_layout

\begin_layout Itemize
self-similarity: each part is a scaled size copy of the whole 
\end_layout

\begin_layout Itemize
fine structure at small scale
\end_layout

\begin_layout Itemize
recursive definition
\end_layout

\begin_layout Standard
The Brownian motion is an example of a stochastic fractal, meaning that,
 unlike the deterministic tree-branching structure, it is self-similar within
 a range of probabilities 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:Witten1982]{(Witten, 1982)}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section*
Angle correction
\end_layout

\begin_layout Standard
Whenever two sibling branches grow too close together, the network provides
 a way of moving the youngest one from the sibling so that the angle between
 them is bigger or equal than a certain user defined value.
 We call 
\begin_inset Formula $\hat{a}$
\end_inset

 the moving vector and 
\begin_inset Formula $\hat{b}$
\end_inset

 the still vector.
 
\begin_inset Formula $\hat{a}$
\end_inset

, 
\begin_inset Formula $\hat{b}$
\end_inset

 are defined as follows.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{a}=(a_{x},a_{y},a_{z})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{b}=(b_{x},b_{y},b_{z})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\mid\hat{a}\mid=\mid\hat{b}\mid=1
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
It is known that 
\begin_inset Formula $cos\vartheta=\frac{\hat{a}\cdot\hat{b}}{\mid\hat{a}\mid\mid\hat{b}\mid}=\hat{a}\cdot\hat{b}$
\end_inset

 from which follows that 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\vartheta=cos^{-1}(\hat{a}\cdot\hat{b})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
One can now decompose 
\begin_inset Formula $\hat{a}$
\end_inset

 as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
a_{//}=cos\vartheta\hat{b}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
a_{\bot}=\hat{a}-a_{//}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
It is also known that
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
tan\vartheta=\frac{\mid a_{//}\mid}{\mid a_{\bot}\mid}\label{eq:tan_theta}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The user defines the new angle between the two vector as 
\begin_inset Formula $\vartheta_{0}$
\end_inset

.
 One can therefore calculate a new 
\begin_inset Formula $\mid a_{\bot}^{\prime}\mid$
\end_inset

 that satisfies the following equation
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\mid a_{\bot}^{\prime}\mid=\mid a_{//}\mid tan\vartheta_{0}\label{eq:new_perp}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
By combining 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:tan_theta"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:new_perp"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
a_{\bot}^{\prime}=a_{\bot}(\frac{\mid a_{//}\mid tan\vartheta_{0}}{\mid a_{\bot}\mid})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
One can therefore define the new position 
\begin_inset Formula $\hat{a}^{\prime}$
\end_inset

 as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
a^{\prime}=a_{//}+a_{\bot}^{\prime}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
and its unit vector as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{a}^{\prime}=\frac{a^{\prime}}{\mid a^{\prime}\mid}
\end{equation}

\end_inset


\end_layout

\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{part}{Acknowledgments}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
blablabla
\end_layout

\begin_layout Part*

\lang english
\begin_inset Newpage cleardoublepage
\end_inset

References
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{part}{References}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:houdini2017"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\lang english
Power Up Your Houdini Skills with SideFX, 2017.
 Making the Last Bastion.
 
\shape italic
3D World Magazine
\shape default
, 20 June 2017, Available from: https://issuu.com/futurepublishing/docs/houdini_i
ssuu [Accessed 24 July 2017].
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:schwank2016"

\end_inset


\end_layout

\begin_layout Standard
Schwank, A., James, C.
 J., Milciotta, T., 2016.
 The Trees of The Jungle Book.
 
\shape italic
SIGGRAPH ’16 Talks
\shape default
, 24-28 July 2016.
 Anaheim, CA: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:keim2016"

\end_inset


\end_layout

\begin_layout Standard
Keim, H., Simmons, M., Teece, D., Reisweber, J., Drakeley, S., 2016.
 Art-Directable Procedural Vegetation in Disney’s Zootopia.
 
\shape italic
SIGGRAPH ’16
\shape default
, 24-28 July 2016.
 Anaheim, CA: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:basalla2005"

\end_inset


\end_layout

\begin_layout Standard
Basalla, D., 2005.
 
\shape italic
Forest Generation with Maya and Renderman
\shape default
.
 Thesis (MSc).
 Bournemouth University.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:smurfs2017"

\end_inset


\end_layout

\begin_layout Standard
SideFX, 2017.
 
\shape italic
Smurfs: The Lost Village
\shape default
.
 sidefx.com, SideFx.
 Available from: https://www.sidefx.com/community/sony-imageworks-smurfs-the-lost-
village/ [Accessed 24 July 2017].
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:shek2010"

\end_inset


\end_layout

\begin_layout Standard
Shek, A., Lacewell, D., Selle, A., Teece, D., Thompson, T., 2010.
 Art-directing Disney's Tangled procedural trees.
 
\shape italic
SIGGRAPH 2010 Talks
\shape default
, 26 - 30 July Los Angeles.
 New York: ACM, 53.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:melson2016"

\end_inset


\end_layout

\begin_layout Standard
Melson, T., 2016.
 Can’t See The Jungle For The Trees.
 
\shape italic
SIGGRAPH ’16 Talks
\shape default
, 24 - 28 July Anaheim, CA.
 New York: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:soares2016"

\end_inset


\end_layout

\begin_layout Standard
Soares, O., Moser, M., Aalbers, F., 2016.
 Vegetation Choreography in The Good Dinosaur.
 
\shape italic
SIGGRAPH ’16 Talks
\shape default
, 24 - 28 July Anaheim, CA.
 New York: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:cieri2016"

\end_inset


\end_layout

\begin_layout Standard
Cieri, S., Muraca, A., Schwank, A., Preti, F., Micilotta, T., 2016.
 The Jungle Book: Art-Directing Procedural Scatters in Rich Environments.
 
\shape italic
DigiPro ’16
\shape default
, 23 - 23 July Anaheim, CA.
 New York: ACM, 57-59.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:runions2007"

\end_inset


\end_layout

\begin_layout Standard
Runions, A., Lane, B., Prusinkiewicz, P., 2007.
 Modeling Trees with a Space Colonization Algorithm.
 In: Ebert, D., Mérillou, S., 
\shape italic
NPH'07 Proceedings of the Third Eurographics conference on Natural Phenomena
\shape default
, 4 September 2007, Prague.
 Aire-la-Ville: Eurographics Association, 63-70.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:camilleri2016"

\end_inset


\end_layout

\begin_layout Standard
Camilleri, E., 2016.
 
\shape italic
Path Planning for Natural Phenomena
\shape default
.
 Thesis (MSc).
 Bournemouth University.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:wang2008"

\end_inset


\end_layout

\begin_layout Standard
Wang, C., Yang, K., Han, D., 2008.
 New Modeling Method for Trees.
 
\shape italic
2008 International Conference on Advanced Computer Theory and Engineering
\shape default
, 20-22 December 2008 Phuket.
 Los Vaqueros Circle: Institute of Electrical and Electronics Engineers
 ( IEEE ), 633-637.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:rodkaew2003"

\end_inset


\end_layout

\begin_layout Standard
Rodkaew, Y., Chongstitvatana, P., Siripani, S., Lursinsap, S., 2003.
 Particle Systems for Plant Modeling.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:weber1995"

\end_inset


\end_layout

\begin_layout Standard
Weber, J., Penn, J., 1995.
 Creation and Rendering of Realistic Trees.
 
\shape italic
22nd International ACM Conference on Computer Graphics and Interactive Technique
s
\shape default
, 6 - 11 August 1995 Los Angeles.
 New York: ACM, 119 - 128.
\end_layout

\end_body
\end_document
