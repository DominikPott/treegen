#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{multirow}
\usepackage{graphicx}
\newcommand{\terminaltext}[1]{{\footnotesize \colorbox{black}{\color{green}\texttt{#1}}}}
\graphicspath{ {images/} }
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Modelling of non-hero vegetation in Houdini
\begin_inset Newline newline
\end_inset


\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Author
Marta Feriani
\begin_inset Newline newline
\end_inset

s4900092
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset


\begin_inset Graphics
	filename images/BUlogo.png

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset FloatList figure

\end_inset


\begin_inset CommandInset toc
LatexCommand lstlistoflistings

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Abstract

\lang english
Vegetation modelling plays a key role in shots composition.
 Achieving a belieavable and true result has proven to be a tedious and
 time consuming task for artists.
 To overcome this issue we present a Houdini toolset for trees and flowers
 modelling.
 Through specifying different parameters values the toolset will generate
 a variety of tree and flowers species.
 Trees structures are achieved using the space colonization algorithm by
\lang british

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:runions2007]{Runions et al (2007)}
\end_layout

\end_inset

.
 Model parameters are meaningful to visual characteristics and offer an
 appropriate control over the silhouette and branching structure.
 Experiments show that the toolset can produce a reasonable variety of trees
 and flower species.
\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Section

\lang english
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:fearing]{Fearing (2000)}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
related works, motivation to do it in houdini
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/MPM.png
	lyxscale 50
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang english
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\lang english
MPM
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:MPM"

\end_inset

MPM method as implemented by 
\lang british

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:stomakhin]{Stomakhin et al (2013)}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Trees
\end_layout

\begin_layout Section
Related Works
\end_layout

\begin_layout Standard
The modelling of natural shapes such as trees is difficult because of the
 richness of small details.
 The history of trees 3D modelling starts with a recursive algorithm proposed
 by Honda (1971) REFERENCE!!!.
 The recursive structure relies on a few geometrical attributes such as
 branching angles and length ratio between consecutive segments.
 Honda also studies the nature of trees branching addressing the monopodial
 branching pattern as a special case for the dichotomous branching for structure
s that are parallel to the gravity.
 Honda's recursive approach has been at the core of many later modelling
 algorithms.
\end_layout

\begin_layout Standard
Lindenmayer (anno) REFERENCE!!!! introduced a string rewriting system know
 as L-System to describe the cellular interaction.
 An L-System is a formal grammar that consists of an alphabet, production
 rules and an axiom.
 The alphabet is a collection of symbols that can be used to produce strings.
 Production rules expand each symbol or string into some larger string.
 The axiom is used as starting point for the production.
 The string produced by iterating over the axiom can be later interpreted
 as geometric commands.
 Prusinkiewicz applies Lindenmayer rewriting system to plants structures
 adding few extensions such as context sensitivity and random variations.
\end_layout

\begin_layout Standard
L-Systems produce good results but the self similarity and the production
 patterns remain clearly visible in the final model.
 To overcome the pattern visibility, literature (REFERENCE) has introduced
 stochastic L-System which involves the selection of a production rule from
 the set based on a probability value.
 Other improvements on L-Systems involve the definition of a container volume
 for the L-System to grow into.
 Given the volume and an initial segment, the system will set the depth
 for the recursion.
\end_layout

\begin_layout Standard
Oppenheimer (anno) REFERENCE also relies on Honda recursive approach by
 developing natural patterns using fractals.
 The fractal specification is based on parameters such as branching angles,
 branch-to-prent ratio and branch-per-stem number.
 The fractal method by Oppenheimer was found to be affected by severe self
 similarity pattern visibility which gave the final shape a machine-made
 look.
 To overcome this problem 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Weber and Penn (1995)}
\end_layout

\end_inset

 improved the recursive model by adding randomness and organized functions
 to affect the tree development.
\end_layout

\begin_layout Standard
The interpretation of a tree as a recursive structure is justified by the
 process of tree development but plays a smaller role for fully grown trees.
 Buds may have different fate such as grown to major limbs, be shed or remain
 small twigs.
 In the architecture of a mature tree, therefore, the regularity of the
 recursive branching is mainly lost, overridden by subsequent development.
 Furthermore, finding rules and fitting parameters for recursive structures
 is a non trivial task.
 A small variation on the initial conditions will propagate exponentially
 through the generations becoming more and more evident.
 Once we managed to define the rules for a tree species, they often result
 to have nothing in common with other tree species.
 Even trying to tweak the existing rules to produce small variation on the
 produced model will drastically affect the whole new structure.
 Given the recursive nature of both L-System and fractals, even the use
 of random variables cannot completely overcome self-similarity issue and
 the resulting architectures give the machine-made impression.
\end_layout

\begin_layout Standard
New models for 3D tree modelling find common ground in the Runion et al
 REFERENCE approach developed for leaves venation.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Rodkaev et al (2003)}
\end_layout

\end_inset

 inherit Runion approach and apply it to a new algorithm based on particles
 that produces realistic leaves venation on a 2D space or a branching structure
 in a 3D space.
 Rodkaev populates a shape or a volume with particles.
 Each particle will move towards a predefined goal position merging with
 neighbours particles when the distance is smaller than a certain threshold.
 The trail for the particles trajectories generates the tree graph.
\end_layout

\begin_layout Section
The method
\end_layout

\begin_layout Standard
Similar to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Rodkaev et al (2003)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:runions2007]{Runions et al (2007)}
\end_layout

\end_inset

 suggest a space colonization algorithm as an extension of the 3D leaves
 venation by Runion et al REFERENCE.
 Unlike Rodkaev, Runions branching structure is formed in a base-to-leaves
 order.
 Each iteration of the algorithm produces new elements that expand the tree
 structure formed in the previous steps.
 This approach results not only to be adaptive to obstacle and neighbour
 plants, but also provides controls over the growth process that results
 in a wide variety of tree structures.
\end_layout

\begin_layout Subsection
Overview
\begin_inset CommandInset label
LatexCommand label
name "subsec:Overview"

\end_inset


\end_layout

\begin_layout Standard
The algorithm proceeds as follows.
 A 3D envelope for the tree crown is specified as input.
 Its volume is seeded with a set of attraction points.
 The attraction points influence the growth of the tree structure by signalling
 the availability of empty space within the tree crown envelope.
 A single point is specified as input and acts as the base of the tree.
 Having the attracting points and the first tree point, the tree structure
 is generated as an iterative process.
 Each iteration produces new tree points in the direction of the neighbour
 attraction points to extend the existing tree structure.
 The algorithm may stop after a user defined number of iterations.
 If let running, the algorithm stops either when there are no attraction
 points within the radius of influence or when there are no attraction points
 left.
\end_layout

\begin_layout Standard
Further manipulation involves subdivision and smoothing of the internodes
 (branch that connects two consecutive nodes of the tree), skinning and
 scattering of organs such as leaves, flowers or fruits.
\end_layout

\begin_layout Subsection
Growth Algorithm
\begin_inset CommandInset label
LatexCommand label
name "subsec:Growth-Algorithm"

\end_inset


\end_layout

\begin_layout Standard
Competition for space plays a fundamental role in the colonization algorithm
 and determines the branching pattern for the tree structure.
 Before delving into the details of the algorithm some definitions and axioms
 are needed.
\end_layout

\begin_layout Subsubsection
Definitions and axioms
\end_layout

\begin_layout Enumerate
Every point the algorithm uses is either a tree node or an attraction node.
 From now on we will refer to tree nodes with 
\begin_inset Formula $v$
\end_inset

 and attraction nodes with 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $N$
\end_inset

 is the set of all the attraction points.
\begin_inset Formula 
\begin{equation}
\forall s,s\in N
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $T$
\end_inset

 is the set for the tree nodes
\begin_inset Formula 
\begin{equation}
\forall v,s\in N
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
If we refer to 
\begin_inset Formula $p$
\end_inset

 as a generic point in the algorithm
\begin_inset Formula 
\begin{equation}
\nexists p(p\in N\land p\in T)
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $S(v)$
\end_inset

 is the set of attraction points 
\begin_inset Formula $s$
\end_inset

 that influence the growth of the tree point 
\begin_inset Formula $v$
\end_inset

 for the current iteration.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $d(a,b)$
\end_inset

 is the Euler distance between point 
\begin_inset Formula $a$
\end_inset

 and point 
\begin_inset Formula $b$
\end_inset

 
\begin_inset Formula 
\begin{equation}
d(a,b)=\sqrt{(a.x-b.x)^{2}+(a.y-b.y)^{2}+(a.z-b.z)^{2}}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $di$
\end_inset

 is the 
\shape italic
radius of influence
\shape default
 which represents the maximum distance between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 so that 
\begin_inset Formula $s\in S(v)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $dk$
\end_inset

 is the 
\shape italic
kill distance
\shape default
.
 If 
\begin_inset Formula $d(s,v)$
\end_inset

 is less than 
\begin_inset Formula $dk$
\end_inset

, 
\begin_inset Formula $s$
\end_inset

 gets removed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $D$
\end_inset

 is the distance between consecutive nodes of the tree
\end_layout

\begin_layout Subsubsection
Steps
\end_layout

\begin_layout Enumerate
Define a 3D shape for the tree crown.
 Initialize the parameters N, di, dk, D.
\end_layout

\begin_layout Enumerate
Populate the 3D envelope with attraction points using a certain random distribut
ion.
\end_layout

\begin_layout Enumerate
Define at least one tree node to act as the base of the tree structure.
\end_layout

\begin_layout Enumerate
Each attraction point 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $s\in N$
\end_inset

, may influence the tree node 
\begin_inset Formula $v$
\end_inset

 that is closest to it.
 The influence occurs if 
\begin_inset Formula $d(s,v)<di$
\end_inset

.
 For each 
\begin_inset Formula $s\in N$
\end_inset

, check if there is any 
\begin_inset Formula $v\in T$
\end_inset

 that meets the condition.
 More than one attraction point may influence the same 
\begin_inset Formula $v$
\end_inset

 tree point: all the attraction points that influence 
\begin_inset Formula $v$
\end_inset

 are gathered in the 
\begin_inset Formula $S(v)$
\end_inset

 set.
\end_layout

\begin_layout Enumerate
For each tree node 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $v\in T$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
, if S(v) is not empty, a new tree node 
\begin_inset Formula $v^{\prime}$
\end_inset

is created.
 The new tree node lies at a distance 
\begin_inset Formula $D$
\end_inset

 from 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $v$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
 in the direction of the average of the normalized vectors towards the attractio
n points 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $s\in S(v)$
\end_inset


\begin_inset Formula 
\begin{equation}
v^{\prime}\in T
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
d(v,v^{\prime})=D\label{eq:newborn_dir_magnitude}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\vec{n}=\sum_{s\in S(v)}\frac{s-v}{\shortparallel s-v\shortparallel}\label{eq:newborn_dir}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\hat{n}=\frac{\vec{n}}{\shortparallel n\shortparallel}\label{eq:newborn_dir_normal}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
v^{\prime}=v+D\hat{n}\label{eq:newborn_position}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate

\lang english
perform a check to test, if any, attraction points 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $s\in N$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 should be removed if the following condition is true for at least one 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $v\in T$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
:
\begin_inset Formula 
\begin{equation}
d(s,v)<dk
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate

\lang english
repeat from steps 4 to 6 until we meet the stop conditions mentioned in
 HYPERREF!!!.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The network for the implementation of the growth algorithm relies on the
 layering of simple rules that eventually lead to the creation of the complexity
 that characterizes trees in nature.
 Houdini supports multiple scripting languages such as HScript, Python and
 VEX.
 Being Python widely used as scripting language and being a reality shared
 between many DCC software, it might seem the most sensible choice.
 On the other hand, VEX scripting language is Houdini native language.
 VEX gives direct access to geometry data and provides a wide variety of
 built-in function optimized for best performances on the Houdini geometry
 internal representation.
 In terms of performances, VEX has proven to be faster than Python because
 it implements automatic multithreading while Python does not have the same
 feature.
\end_layout

\begin_layout Subsection
Wrangle Node
\end_layout

\begin_layout Standard
The wrangle node REFERENCEEEEE is the most present node type in the network
 therefore it seemed only natural to give a brief explanation of how it
 works.
\end_layout

\begin_layout Standard
METTICI UNA IMMAGINE The attribute wrangle is a low level node that allows
 for the tweaking of the geometry attributes using VEX code.
 Its capabilities correspond to the Attribute VOP SOP.
 The main difference between the two of them is that wrangle uses a a textual
 editor whilst the Attribute VOP SOP uses a visual network.
\end_layout

\begin_layout Standard
The node can edit the input geometry by changing or adding attributes.
 It can also remove or create new geometry for example by adding points,
 linking points together to create polygons and so on.
 The snippet runs on details or on every point/primitive/vertex of the first
 input geometry.
 Using the multiple sources to the node it is also possible to access data
 from different geometry at the same time.
 When having multiple sources, only the first input geometry will flow down
 to the next node of the network whilst the other input geometries will
 be lost.
\end_layout

\begin_layout Standard
When the snippet affects the attributes of the geometry, these attribute
 will not be available until the node is cooked.
 This often makes is difficult to populate geometry attributes such as array
 within the same wrangle node.
 Due to this, the implementation of particular parts of the growth algorithm
 might not seem the most straightforward or obvious way to approach the
 problem but have been deliberately tweaked to overcome this particular
 issue.
\end_layout

\begin_layout Subsection
Data structure
\begin_inset CommandInset label
LatexCommand label
name "subsec:Data-structure"

\end_inset


\end_layout

\begin_layout Standard
The growth algorithm, as presented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Growth-Algorithm"

\end_inset

, mostly relies on points position.
 Each point has certain attributes to make it possible to create the tree
 structure.
 The attribute @type divides the point set in two main categories respectively
 the tree nodes and the attraction points.
 Given the nature of the algorithm, the total number of attraction points
 will decrease each iteration whilst every new node that will be created
 will increase the count for the tree nodes.
 To give a better visualization for this partition, the colour attribute
 @Cd is initialized to {1, 0.5, 0} for the tree node and to {0, 0.5, 1} for
 the attraction points.
\end_layout

\begin_layout Standard
The aim of the algorithm is to create a believable branching structure to
 reproduce natural trees.
 Stems might grow in only one direction or fork producing new stems.
 Older stems also grow thicker to balance the weight of the younger stems.
 This branching pattern can be represented by an acyclic graph data structure.
\end_layout

\begin_layout Standard
A graph is a finite collection of vertices and edges.
 Graph are used to model pairwise relations between object.
 The vertices, or nodes, represent the objects while the edges are the relations.
 The different nature of the relations leads to different kinds of graphs.
 In the case of a directed graph, each edge has an orientation, from one
 vertex to another vertex.
 A path is a sequence of edges.
 A node A is reachable by another node B if there exists a path that leads
 from A to B.
 If for each node in the graph there is no path that connects the node to
 itself, the graph is said to be acyclic.
 Being a graph a hierarchical structure, it is appropriate to address relationsh
ip between nodes as parent/child relationship.
 Each node is therefore aware either of its parent, its children or both.
 In computer science, to reproduce the relationships between nodes, each
 node contains a pointer to the connected ones.
 The network developed for this project provides each tree node with two
 attributes an integer and an array to store references to the parent and
 the children respectively.
 Unfortunately Houdini does not have pointers like structures.
 The points of a geometry are stored in an array like structure.
 The @ptnum attribute refers to the index of the point in that array.
 When referring to a point using the @ptnum attribute, one can gain direct
 access to that points other attributes, either built in or custom.
 Unfortunately, being the @ptnum ultimately just an index in an array, its
 value is not consistent through the network.
 Operation such as adding or removing points or merging together two geometry
 may shift or offset the @ptnum value.
 Given its unstable nature, the @ptnum did not seem to be a suitable choice
 to build parent/child relation upon.
 As a workaround, each treepoint also stores a unique identifier @id.
 Smaller @id values belong to older tree points while greater values belong
 to younger ones.
 When populating the @parent and @kids attributes, the reference to the
 other points will not be represented by the @ptnum but by the @id instead.
 Having to rely on a custom attribute such as the @id automatically translate
 into losing the direct access granted by the @ptnum.
 This greatly affects the performances of the whole algorithm because in
 order to find a node with a specific @id, one has to cycle over each point
 of the geometry and check for a match.
 In order not to loose this convenient feature, every time the algorithm
 has to work on the tree nodes, the sort node is used to remap the @ptnum
 based on the @id value.
 This solution allows for a reliable hierarchy structure while maintaining
 speed of access.
\end_layout

\begin_layout Standard
Another important information about the tree nodes is the grow direction
 and the length of the internode.
 Storing this values make it possible for a later more detailed manipulation
 of branching angles.
 Each point therefore stores a @growdir attribute that holds the normalized
 growth vector that links the parent to the node point position.
\end_layout

\begin_layout Standard
As a final step, each node also has two flags respectively for death and
 fertility.
 While the fertility flag signals if the node can produce a child in the
 current iteration and can be therefore non fertile and fertile in two consecuti
ve iteration, when the death flag is set it determines an irreversible condition
 for the node.
 A node dies whenever it reaches the maximum amount of children or for degenerat
ed cases such as the position of the child node being coincident with its
 own position.
\end_layout

\begin_layout Standard
As the information needed on a per node basis are quite important in terms
 of quantities, whenever an attribute is not needed any longer, it is removed
 from the geometry.
\end_layout

\begin_layout Subsection
Parameter initialization
\end_layout

\begin_layout Standard
define the 3D envelop, user input, choice on how many iteration, D, Dk,
 Di scaling factor (manipulated through the generations).
 Root point input as just points or a user selected trunk.
 Explanation of the algorithm for just nodes, new chapter for user defined
 trunk and branches.
\end_layout

\begin_layout Standard
In order for the growth algorithm to start, some parameters have to be set
 such as the tree crown envelope, the attraction points position and the
 roots points.
\end_layout

\begin_layout Subsubsection
Tree crown
\end_layout

\begin_layout Standard
The network provides up to three different ways to specify the crown volume
 for the tree.
 All of them take as an input polygonal shapes that are later converted
 to volume.
 At its very basic implementation, the user specified tree crown is converted
 to a volume using the Isooffset node.
 The conversion result to be necessary in order to populate the crown tree
 volume with the attraction points.
 Moving from the base implementation, the user can specify a collision object
 for the tree crown to interact width.
 This options makes it possible to simulate a tree growth process where
 the final shape is affected by the surrounding obstacles.
 The collision object is then converted to a volume.
 To identify the viable area for the tree to grow, the volume mix node performs
 the subtraction operation between the two input volumes.
 The resulting volume is then used for the tree to grow.
 Another option allows the user to specify not the crown tree volume directly
 but calculates the viable space for growth from a given object.
 The input geometry is converted to volume twice: the first conversion replicate
s the input geometry closely whilst the second one will inflate the volume
 with a user defined offset.
 The difference between the volumes will create a layer wrapped around the
 initial object.
 This option can convey the illusion of a plant clinging and growing finding
 support on an object, like vines do.
\end_layout

\begin_layout Standard
Unfortunately the conversion from polygon to volume can produce artefacts
 due to the conversion method used by the Isooffset node.
 Different workarounds to this problem have been tried but none of them
 proved to be successful for all kinds of input geometry.
 IMMAGINE DEL PROBLEMA
\end_layout

\begin_layout Subsubsection
Attraction Points
\end_layout

\begin_layout Standard
At early stages of the production, the volume obtained from the tree crown
 shape was seeded with points with a uniform distribution.
 The resulting trees, as described by Runion (REFERENCEEEEE) shows a uniform
 density in the branches distribution.
 In many trees and shrubs however, the density increases near the crown
 surface due to better light exposure.
 To achieve the same result, following Runion suggestion, the network implements
 a custom scattering distribution.
 As a first step, the tree crown is still seeded with attraction points
 using a uniform distribution.
 A wrangle node 
\begin_inset Quotes eld
\end_inset

distance_from_bounding_object
\begin_inset Quotes erd
\end_inset

 evaluates, for each attraction point, the distance from the bounding object
 provided as a second input to the node.
 The resulting value is stored to an attribute named @dist.
 The promote Houdini node is used twice to find respectively the maximum
 distance @max_dist and the minimum distance @min_dist for the @dist attribute.
 These information feed a second wrangle node 
\begin_inset Quotes eld
\end_inset

radial_distribution
\begin_inset Quotes erd
\end_inset

: each node @dist value is taken from its original range (@min_dist, @max_dist)
 and shifted to its corresponding value in the new range (0, 1).
 The resulting variable is linked to a user customizable ramp.
 The value from the ramp represents the probability for the attraction point
 to survive.
 A random number based on the @ptnum of the current attraction point is
 calculated and compared to the probability value.
 If it results to be less, the attraction point gets removed.
 The ramp extends the potential of Runion idea by giving the users not only
 control over the density near the crown surface but providing them with
 a greater art directability over the branches density from the centroid
 of the shape to its boundaries.
\end_layout

\begin_layout Standard
The same principles are used to define a second custom distribution that
 uses the Y coordinate of the point position is used instead of the distance
 from the object (
\begin_inset Quotes eld
\end_inset

AP_height
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

vertical_distribution
\begin_inset Quotes erd
\end_inset

).
 The newly generated attraction points are then initialized.
 
\end_layout

\begin_layout Subsubsection
Roots
\end_layout

\begin_layout Standard
The network provides three different ways to specify the roots for the growth
 algorithm.
 An user can either create single root points by specifying the coordinates,
 input a premade set of points or a trunk and branches curves structure.
\end_layout

\begin_layout Standard
For the first two option the initialization of the nodes attributes follows
 the same process.
 All the root points @parent is set to -1 to signal that they do not have
 any parent.
 As said before, the colour @Cd is initialized to yellow {1, 0.5, 0} and
 the @kids is declared as an empty array, the @type to 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

.
 Space will be allocated for for the @growdir @n_dead and @attr_dead.
 The initial values for these parameters are respectively {0, 0, 0}, 0 meaning
 that the node is alive and -1 to signal a default value.
\end_layout

\begin_layout Standard
The initialization of some attributes such as @parent, @kids and @type differs
 in the case of a custom trunk structure is fed in the system.
 This kind of structure already contains primitive information that link
 together points in a precise hierarchy.
 The most likely scenario is that each branch is represented as a curve
 primitive.
 The fork points of the structure will then belong to two different primitive
 at once, for example to both the trunk and a branch.
 The first attribute to be initialized is the @kids array using the 
\begin_inset Quotes eld
\end_inset

trunk_kids
\begin_inset Quotes erd
\end_inset

 snippet.
 This wrangle node is encapsulated in a for loop nodes block that will iterate
 on each primitive of the input geometry.
 The wrangle will therefore process the points of one primitive at the time.
 In the wrangle interface, the snippet is set to run over details so that
 the iteration process over the points is explicitly declared in in the
 code.
 The snippet starts by retrieving an ordered array of the current primitive
 points.
 A for loop then iterates over this array reading the point value and assigning
 the next point in the array to itself as @kids element.
 By using this approach, the snippet successfully handles specific cases
 in which the children to the point belong to different primitives.
 After having initialized the @kids attribute, the @parent comes straightforward
: the 
\begin_inset Quotes eld
\end_inset

trunk_parent
\begin_inset Quotes erd
\end_inset

 wrangle iterates over each point of the input geometry regardless the primitive
 they belong to.
 Each point will read its own @kids list and proceeds to set itself as @parent
 attribute to these points.
 One can refer to this process as parent injection.
 It is important to highlight that at this stage the @id attribute described
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Data-structure"

\end_inset

 has still not been initialized.
 The parent-children relation is built on the @ptnum.
 It is also important to understand that in this particular part of the
 network all the geometry being processed belongs to the tree structure.
 The @id can be therefore initialized as a plain copy of the @ptnum.
 Being @ptnum and @id coincident at this stage, the initialization process
 described results to be correct.
 As a next step, the @type has to be set.
 The implementation process makes sure that the user is given a certain
 extent of controls over the choice of root points for the growth algorithm.
 The network highlights as candidate roots all the points contained within
 the volume of the tree crown shape.
 The user can then decide which of them to keep.
 For the selected points, the @type is set to 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

 while the remaining ones are set to 
\begin_inset Quotes eld
\end_inset

trunk
\begin_inset Quotes erd
\end_inset

.
 During the growth algorithm, only the nodes will interact while the others
 will be lifeless.
 A final attribute @generation is initialized for all root points regardless
 whether they are single points or points being selected from a custom structure.
 This attribute plays a key role in a later part of the network to set and
 scale the cross section of the branches according to their age.
\end_layout

\begin_layout Subsection
Growth
\end_layout

\begin_layout Standard
The growth main algorithm lies inside a dedicated subnetwork 
\begin_inset Quotes eld
\end_inset

growing_alg
\begin_inset Quotes erd
\end_inset

.
 This subnetwork mainly consists of a for loop that determines the number
 of time the geometry is processed.
 Contrary to the stop conditions presented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Overview"

\end_inset

, the loop will only terminate after an user defined number of iterations.
 It can happen that the user require the algorithm to run more times than
 the ones required to meet the stop condition.
 In this case, even though the network will continue iterating, no new geometry
 is created.
 When running the algorithm, the user has also control over the values for
 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $dk$
\end_inset

 and 
\begin_inset Formula $di$
\end_inset

.
\end_layout

\begin_layout Standard
Before delving in the growth loop, the wrangle 
\begin_inset Quotes eld
\end_inset

AD_treepts
\begin_inset Quotes erd
\end_inset

 sets a detail attribute over the geometry that specifies the total number
 of treepoints based on the @type attribute of the points.
 This is later used to produce the @id for the new born nodes.
\end_layout

\begin_layout Standard
At this stage as well, points with type 
\begin_inset Quotes eld
\end_inset

trunk
\begin_inset Quotes erd
\end_inset

 are filtered out of the growth process and rejoined with the rest of the
 geometry when the process ends.
\end_layout

\begin_layout Subsubsection
Finding neighbours
\end_layout

\begin_layout Standard
The nodes and the attraction points are divided based on the @type value.
 In order to keep the calculation as light as possible, a preparation step
 is undertaken using the 
\begin_inset Quotes eld
\end_inset

find_influencing_attr
\begin_inset Quotes erd
\end_inset

 before finding the closest tree node of each attraction point.
 The wrangle receives as first input geometry the set 
\begin_inset Formula $N$
\end_inset

 of the attraction points and as second input the set 
\begin_inset Formula $T$
\end_inset

 of tree nodes.
 The node purpose is to isolate the attraction points that will influence
 the tree growth for the current iteration from the inert ones.
 The snippet is set to run over details.
 Iterating over each tree node, a function _setInfluencing() is invoked.
 The function takes as an input a the position of the tree node.
 Based on that position, the function retrieves all the attraction points
 that are closer than the user defined 
\begin_inset Formula $di$
\end_inset

 distance.
 Every attraction point that satisfies this condition is flagged as influence
 node.
 The set of influence node is therefore a subset of the set 
\begin_inset Formula $N$
\end_inset

 of all the attraction points.
 Using the blast node, the influencing nodes are separated from the other
 inactive attraction points.
 The tree nodes and the influencing nodes are wired into the 
\begin_inset Quotes eld
\end_inset

find_neighbour
\begin_inset Quotes erd
\end_inset

 subnetwork.
 The search for the closest tree node is implemented in 
\begin_inset Quotes eld
\end_inset

fast_search
\begin_inset Quotes erd
\end_inset

: the wrangle takes as first input geometry the tree nodes and as a second
 input geometry the influencing points.
 At this stage not only each influencing point will look for its closest
 tree point but the sets 
\begin_inset Formula $S(v)$
\end_inset

 are populated as well.
 In this implementation the set is stored as a tree node array attribute
 @nbrs and will contain the @ptnum for all the influencing points for which
 the node is the closest of the tree nodes.
 This operation can be computationally heavy, therefore the following algorithm
 has been developed aiming to optimize such operations.
 The algorithm is divided in three parts:
\end_layout

\begin_layout Itemize
an array closest[] is declared to have the same size as the total count
 of influencing points.
 Starting from the index 0, the influencing point with @ptnum 0 is processed.
 The point will search for the closest tree node and will store its value
 in the array.
 The process moves to index 1 and processes the influencing point with @ptnum
 1 and so on until the closest[] array is completely populated.
 Given the population process, the indices of the closest[] array represent
 the influencing points.
\end_layout

\begin_layout Itemize
two new array are created:
\end_layout

\begin_deeper
\begin_layout Itemize
the argsort function applied to the closest[] array will return a list of
 indices that, if applied to the closest[] will give a sorted sequence in
 an increasing order.
 In this particular case, the indices represent the influencing points.
 The newly created ordered_attr[] array holds therefore a sorted sequence
 for the influencing points.
\end_layout

\begin_layout Itemize
the sort function applied to the closest[] will return a sorted array in
 increasing order.
 This new array is the ordered_closest[]
\end_layout

\end_deeper
\begin_layout Itemize
using the newly created arrays, the algorithm proceeds to locate the sets
 S(v) and store them in the proper tree nodes.
 The sets are consecutive chunks of the ordered_attr[] array.
 To tokenize it properly, the ordered_closest[] is used.
 A for loop iterates over the length of the array.
 The value of ordered_attr[i] is stored in a new temporary array nbrs[].
 A check is performed to compare the current element for ordered_closest
 and its consecutive one.
 It the two do not match, it means that the end of the current set S(v)
 has been reached.
 The temporary array is assigned as @nbrs attribute to the tree node specified
 in ordered_closest[i].
 The temporary array is cleared for the next set.
\end_layout

\begin_layout Standard
The algorithm proved to be dramatically faster compared to its basic implementat
ion.
 The reader can compare the performances by switching the input for the
 switch node in the 
\begin_inset Quotes eld
\end_inset

grow_alg/find_neighbour
\begin_inset Quotes erd
\end_inset

 subnetwork.
 The approach undertaken here also improved Runion algorithm by reducing
 the number of computation required to achieve the result.
 IMMAGINE ALGORITMO, IMMAGINE NETWORK
\end_layout

\begin_layout Subsubsection
Set fertility for the tree nodes
\end_layout

\begin_layout Standard
Extending Runion's algorithm further, the user can specify the maximum count
 of branches that a node can generate and from which generation the nodes
 can begin the branching process.
 This node gives a better control over the final tree structure as it allows
 to achieve a sparser result when reducing the count of children per node.
 By choosing the generation from which to start branching, the user can
 enhance the visual impact of the main trunk structure.
 The wrangle 
\begin_inset Quotes eld
\end_inset

set_fertility
\begin_inset Quotes erd
\end_inset

 operates over this constraints: the eligible nodes for the production of
 a new tree node are flagged as fertile.
 Another check is here performed: in the case the node has already reached
 the maximum count of children allowed, the node is flagged as dead and
 becomes inactive for all the remaining iterations of the growth algorithm.
\end_layout

\begin_layout Subsubsection
Calculate new born direction
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

newborn_dir
\begin_inset Quotes erd
\end_inset

 wrangle runs over each tree point that is fed as a first input geometry.
 If the node results to be fertile, the snippet proceeds to retrieve the
 identifiers of the influencing points to that tree node stored in the @nbrs
 array attribute.
 The set of all the influencing points is fed to the wrangle as a second
 input geometry.
 Having the identifiers for the influencing points and the influencing points
 geometry as input, the algorithm can use the identifiers as lookup keys
 to retrieve the position of the influencing points.
 The growth direction for the future newborn is then calculated using 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:newborn_dir"

\end_inset

.
 The normalized 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:newborn_dir_normal"

\end_inset

 result is stored in the vector attribute @dir of the tree node.
 This way, the parent node is in charge of holding all the information needed
 to later create and initialize correctly the new born nodes.
 Before moving on to the next step of the network, the snippet checks for
 degenerated cases for which the magnitude of the @dir vector is 0, which
 happens whenever the @nbrs list of influencing points is empty.
 These nodes are declared dead and their fertility flag reset to 0.
\end_layout

\begin_layout Subsubsection
Creation of the new node
\end_layout

\begin_layout Standard
create_new_node
\end_layout

\begin_layout Standard
separation between oldnodes and newborn and non fertile
\end_layout

\begin_layout Standard
set_id
\end_layout

\begin_layout Standard
update_parent
\end_layout

\begin_layout Standard
merge treenodes together
\end_layout

\begin_layout Subsubsection
Remove attraction points
\end_layout

\begin_layout Standard
set_dead_attr
\end_layout

\begin_layout Subsubsection
Preparation to next iteration
\end_layout

\begin_layout Standard
reset direction, fertile and nbrs for nodes, join them back together
\end_layout

\begin_layout Subsubsection
Extra controls
\end_layout

\begin_layout Standard
number of children, correction angle, distance pruning, probability pruning,
 scale D, dk while running
\end_layout

\begin_layout Subsection
Linking the points
\end_layout

\begin_layout Standard
blablabla
\end_layout

\begin_layout Subsection
Cross section evaluation
\end_layout

\begin_layout Standard
blablabla
\end_layout

\begin_layout Part
Flowers
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Subsection
Network
\end_layout

\begin_layout Subsection
User Interface
\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Part*

\lang english
\begin_inset Newpage cleardoublepage
\end_inset

References
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{part}{References}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:houdini2017"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\lang english
Power Up Your Houdini Skills with SideFX, 2017.
 Making the Last Bastion.
 
\shape italic
3D World Magazine
\shape default
, 20 June 2017, Available from: https://issuu.com/futurepublishing/docs/houdini_i
ssuu [Accessed 24 July 2017].
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:schwank2016"

\end_inset


\end_layout

\begin_layout Standard
Schwank, A., James, C.
 J., Milciotta, T., 2016.
 The Trees of The Jungle Book.
 
\shape italic
SIGGRAPH ’16 Talks
\shape default
, 24-28 July 2016.
 Anaheim, CA: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:keim2016"

\end_inset


\end_layout

\begin_layout Standard
Keim, H., Simmons, M., Teece, D., Reisweber, J., Drakeley, S., 2016.
 Art-Directable Procedural Vegetation in Disney’s Zootopia.
 
\shape italic
SIGGRAPH ’16
\shape default
, 24-28 July 2016.
 Anaheim, CA: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:basalla2005"

\end_inset


\end_layout

\begin_layout Standard
Basalla, D., 2005.
 
\shape italic
Forest Generation with Maya and Renderman
\shape default
.
 Thesis (MSc).
 Bournemouth University.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:smurfs2017"

\end_inset


\end_layout

\begin_layout Standard
SideFX, 2017.
 
\shape italic
Smurfs: The Lost Village
\shape default
.
 sidefx.com, SideFx.
 Available from: https://www.sidefx.com/community/sony-imageworks-smurfs-the-lost-
village/ [Accessed 24 July 2017].
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:shek2010"

\end_inset


\end_layout

\begin_layout Standard
Shek, A., Lacewell, D., Selle, A., Teece, D., Thompson, T., 2010.
 Art-directing Disney's Tangled procedural trees.
 
\shape italic
SIGGRAPH 2010 Talks
\shape default
, 26 - 30 July Los Angeles.
 New York: ACM, 53.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:melson2016"

\end_inset


\end_layout

\begin_layout Standard
Melson, T., 2016.
 Can’t See The Jungle For The Trees.
 
\shape italic
SIGGRAPH ’16 Talks
\shape default
, 24 - 28 July Anaheim, CA.
 New York: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:soares2016"

\end_inset


\end_layout

\begin_layout Standard
Soares, O., Moser, M., Aalbers, F., 2016.
 Vegetation Choreography in The Good Dinosaur.
 
\shape italic
SIGGRAPH ’16 Talks
\shape default
, 24 - 28 July Anaheim, CA.
 New York: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:cieri2016"

\end_inset


\end_layout

\begin_layout Standard
Cieri, S., Muraca, A., Schwank, A., Preti, F., Micilotta, T., 2016.
 The Jungle Book: Art-Directing Procedural Scatters in Rich Environments.
 
\shape italic
DigiPro ’16
\shape default
, 23 - 23 July Anaheim, CA.
 New York: ACM, 57-59.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:runions2007"

\end_inset


\end_layout

\begin_layout Standard
Runions, A., Lane, B., Prusinkiewicz, P., 2007.
 Modeling Trees with a Space Colonization Algorithm.
 In: Ebert, D., Mérillou, S., 
\shape italic
NPH'07 Proceedings of the Third Eurographics conference on Natural Phenomena
\shape default
, 4 September 2007, Prague.
 Aire-la-Ville: Eurographics Association, 63-70.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:camilleri2016"

\end_inset


\end_layout

\begin_layout Standard
Camilleri, E., 2016.
 
\shape italic
Path Planning for Natural Phenomena
\shape default
.
 Thesis (MSc).
 Bournemouth University.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:wang2008"

\end_inset


\end_layout

\begin_layout Standard
Wang, C., Yang, K., Han, D., 2008.
 New Modeling Method for Trees.
 
\shape italic
2008 International Conference on Advanced Computer Theory and Engineering
\shape default
, 20-22 December 2008 Phuket.
 Los Vaqueros Circle: Institute of Electrical and Electronics Engineers
 ( IEEE ), 633-637.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:rodkaew2003"

\end_inset


\end_layout

\begin_layout Standard
Rodkaew, Y., Chongstitvatana, P., Siripani, S., Lursinsap, S., 2003.
 Particle Systems for Plant Modeling.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:weber1995"

\end_inset


\end_layout

\begin_layout Standard
Weber, J., Penn, J., 1995.
 Creation and Rendering of Realistic Trees.
 
\shape italic
22nd International ACM Conference on Computer Graphics and Interactive Technique
s
\shape default
, 6 - 11 August 1995 Los Angeles.
 New York: ACM, 119 - 128.
\end_layout

\end_body
\end_document
